## 23년 12월 3일

1. 엔드포인트에서 발생할 수 잇는 문제점 및 해결책
    - 잘못된 사례
        - GET /missions/{mission_number}/{user_id}
        - GET /missions/success-streak/{family_id}
    - 엔드포인트 충돌: {mission_number}는 숫자일 가능성이 높은데, 이는 'success-streak'와 같은 문자열과 충돌할 수 있음. 만약 누군가 /missions/success-streak/{family_id} 엔드포인트를 호출하려고 하면, 서버는 이를 /missions/{mission_number}/{user_id}로 해석할 수 있음. 이런 문제는 엔드포인트의 설계 단계에서 해결해야 함.
        - 해결책: 엔드포인트의 설계 단계에서 이를 방지할 수 있음. 예를 들어, 숫자인 mission_number와 문자열인 'success-streak'를 구분하는 방법 중 하나는 'success-streak'를 '/missions/success-streak'로 고정하고, mission_number를 '/mission/number/{mission_number}'와 같이 변경하는 것.
    - 파라미터 값의 유효성: {mission_number}, {user_id}, {family_id}는 특정한 형식이나 범위를 가지고 있을 가능성이 높음. 만약 사용자가 잘못된 형식이나 범위의 값을 입력한다면, 서버에서는 예상치 못한 오류를 반환하거나 잘못된 데이터를 반환할 수 있음.
        - 해결책: 사용자 입력값의 유효성을 체크하는 로직을 추가하면 이 문제를 해결할 수 있음. {mission_number}, {user_id}, {family_id}의 형식이나 범위를 알고 있다면, 이에 맞는 값만 받아들이도록 서버를 구성하면 됨. 이러한 유효성 체크는 클라이언트 측에서도, 서버 측에서도 수행될 수 있음.
    - 권한 문제: 각 엔드포인트가 특정 사용자 또는 그룹에 대한 정보를 반환한다면, 요청하는 사용자가 해당 정보에 대한 접근 권한을 가지고 있는지 확인해야 함. 이를 확인하지 않으면 보안 문제가 발생할 수 있음.
        - 해결책: 권한 관리는 일반적으로 인증(Authentication)과 권한 확인(Authorization) 두 단계로 이루어짐. 사용자가 누구인지 확인하는 인증 과정 후, 해당 사용자가 요청한 리소스에 대한 접근 권한이 있는지를 체크함. 이를 통해 권한이 없는 사용자의 요청을 거부할 수 있음.
    - 데이터 미존재: 요청된 {mission_number}, {user_id}, {family_id}에 해당하는 데이터가 서버에 존재하지 않을 경우, 적절한 오류 메시지와 함께 처리되어야 함.
        - 해결책: 데이터가 존재하지 않을 경우, 서버는 적절한 HTTP 상태 코드(예: 404 Not Found)와 함께 오류 메시지를 반환해야 함. 이렇게 하면 클라이언트는 요청이 실패한 이유를 알 수 있음.
    - 서버 성능 문제: 만약 많은 양의 데이터를 처리해야 한다면, 이는 서버에 부하를 줄 수 있으며 응답 시간을 늦출 수 있음. 이를 위해 페이징, 캐싱 등의 기술이 사용될 수 있음.
        - 해결책: 페이징(Pagination)을 이용하면 한 번에 전체 데이터를 불러오는 대신, 일부분만 불러올 수 있음. 또한 캐싱(Caching)을 이용하면 자주 요청되는 데이터를 미리 저장해두어 서버의 부하를 줄일 수 있음. 이외에도 로드 밸런싱(Load Balancing), 비동기 처리(Asynchronous Processing) 등의 방법이 있음.
2. 엔드포인트 충돌 방지를 구조 및 규칙 설정법
    - 계층적 구조 설정: URI는 보통 계층적인 구조를 가지고 있음. 이를 활용하여 엔드포인트를 명확히 구분할 수 있음. 예를 들어, GET /missions/{mission_number}/{user_id}와 GET /missions/success-streak/{family_id}에서 충돌이 발생한다면, GET /missions/numbers/{mission_number}/{user_id}와 GET /missions/streaks/{family_id}처럼 계층을 추가하여 구분할 수 있음.
    - 명확한 규칙 설정: 엔드포인트의 일부분이 항상 특정한 형식을 따른다면, 이를 규칙으로 설정하여 충돌을 방지할 수 있음. 예를 들어, {mission_number}가 항상 숫자라면, 이를 나타내는 부분의 경로는 항상 숫자만 받아들이도록 설정할 수 있음.
    - 경로 변수와 리터럴 구분: 경로에 변수와 리터럴이 함께 있는 경우, 변수와 리터럴을 명확히 구분할 수 있도록 설계하는 것이 좋음. 예를 들어, GET /missions/{mission_number}/mission의 경우, {mission_number}와 mission이 충돌할 수도 있음. 이를 방지하기 위해 GET /missions/numbers/{mission_number}/details와 같이 변경할 수 있음.
    - 서버 측에서의 처리: 서버 측에서 요청 경로를 분석하여, 가능한 충돌을 방지하는 로직을 추가할 수도 있음. 예를 들어, 'success-streak'라는 문자열이 포함된 요청을 항상 특정 엔드포인트로 처리하도록 설정할 수 있음.
        - FastAPI에서는 라우트 선언 순서에 따라 요청을 처리하는 방식을 사용. 라우트 선언 순서가 먼저인 엔드포인트가 요청을 먼저 처리함.
3. path, query, body, header
    - Path parameter
        - URL의 일부로 데이터를 전달하는 방식. 주로 리소스의 식별자를 표현하는데 사용됨. 필수적인 데이터를 전달하는데 적합함.
    - Query parameter
        - URL의 끝 부분에 ? 다음에 key-value 형태로 데이터를 전달하는 방법. 주로 정렬, 필터링, 페이징 등의 옵션을 전달하는데 사용됨. 
        - query parameter의 순서는 일반적으로 중요하지 않음
        - 하나의 key에 대해 여러 개의 값을 전달할 수 있음
        - query parameter는 URL의 일부분이므로, URL에 사용할 수 없는 특수 문자를 포함하는 경우 URL 인코딩이 필요함.
        - URL의 최대 길이는 브라우저나 서버 설정에 따라 제한이 있을 수 있음. 일반적으로 URL의 최대 길이는 2000~3000문자로, 이보다 많은 데이터를 전달하려면 요청 본문을 사용해야 함.
    - Body
        - HTTP 요청의 본문에 데이터를 포함시켜 전달하는 방법. 주로 POST, PUT, PATCH 등의 메서드에서 사용됨. 복잡한 뎅터 구조를 전달하거나, 큰 용량의 데이터를 전달하는데 적합함. 
    - Header
        - 클라이언트와 서버가 요청이나 응답을 처리하는 방법에 대한 추가 정보를 제공함
        - 여러 가지 용도로 사용되며, 각각의 사용 상황에 따라 적절한 헤더를 사용해야 함
            - 인증 정보 전달: Authorization 헤더는 클라이언트가 서버에게 인증 정보를 제공하는데 사용됨. 예를 들어, JWT(JSON Web Token) 기반의 인증에서는 Authorization: Bearer {token} 형태로 토큰을 전달함.
            - 콘텐츠 타입 명시: Content-Type 헤더는 요청이나 응답 본문의 미디어 타입을 명시하는데 사용됨. 예를 들어, JSON 형식의 데이터를 전달하는 경우 Content-Type: application/json으로 설정함.
            - 캐싱 제어: Cache-Control, ETag 등의 헤더는 응답 결과를 클라이언트에서 캐싱하고, 캐싱된 결과를 재사용할지 결정하는데 사용됨.
            - 요청과 응답의 언어 설정: Accept-Language 헤더는 클라이언트가 선호하는 언어를 서버에게 알리는데 사용되며, 서버는 이를 바탕으로 적절한 언어의 응답을 제공할 수 있음.
4. 앱에서만 사용자 인증을 수행할 때
    - 로직
        1. 앱에서 사용자 인증: 앱에서 카카오, 애플 OAuth를 통해 사용자 인증을 수행함. 이 과정에서 얻은 액세스 토큰을 사용하여 사용자의 ID를 가져옴.
        2. 토큰 생성: 사용자 ID를 이용하여 서버에서 JWT를 생성함. 이 JWT에는 사용자 ID 외에도 다양한 정보(예: 권한, 만료 시간 등)를 담을 수 있음.
            - 사용자가 서버에 ID를 안전하게 보낼 수 있게 해주는 방법으로는 API 키, IP 화이트리스트, SSL/TLS 등이 있음.
        3. 토큰 전달: 생성된 JWT를 앱에 전달함. 앱은 이 JWT를 저장하고 있다가 서버에 요청을 보낼 때마다 이를 HTTP 헤더 등에 포함시켜 보냄.
        4. 서버에서 토큰 검증: 서버는 요청을 받을 때마다 JWT를 확인하여 사용자의 인증 및 인가를 수행함. JWT는 서명이 포함되어 있어서, 변조가 불가능하게 설계되어 있음.
    - 보안 문제
        - 세션 하이재킹(Session Hijacking): 악의적인 사용자가 세션을 탈취하여 사용자를 가장하고 앱을 사용할 수 있음. 이것은 사용자의 데이터 무결성을 손상시킬 수 있음.
        - 중간자 공격(Man-in-the-middle Attack): 악의적인 사용자가 사용자와 서버 사이에 위치하여 통신을 가로챌 수 있음. 이렇게 되면 사용자의 요청을 변조하거나 서버의 응답을 변조할 수 있음.
        - 리플레이 공격(Replay Attack): 악의적인 사용자가 사용자의 요청을 도청한 뒤, 이를 재생하여 서버에 요청할 수 있음. 이렇게 되면 사용자가 요청하지 않은 작업이 수행될 수 있음.
    - 해결법
        - 토큰 기반 인증(Token Based Authentication): 사용자 인증 후, 서버는 사용자에게 토큰을 발급함. 사용자는 이 토큰을 이용하여 요청을 할 때마다 서버에서는 이 토큰을 검증함. 토큰이 유효하지 않다면 요청은 거부됨. 토큰은 일정 시간 후에 만료되므로, 세션 하이재킹이나 리플레이 공격에 대한 위험을 줄일 수 있음.
        - HTTPS 사용: HTTPS는 SSL/TLS를 이용하여 통신의 보안을 유지함. 이를 통해 중간자 공격을 방지할 수 있음.
        - OAuth 2.0 이용: 카카오, 애플 등의 OAuth 서비스를 이용하면, 각 서비스에서 제공하는 인증 방식을 이용할 수 있음. 이를 통해 사용자 인증 과정이 안전하게 이루어질 수 있음.
5. 데이터 무결성
    - 데이터의 정확성, 일관성, 신뢰성이 유지되는 것
    - 정확성(Accuracy): 데이터가 정확해야 합니다. 오류나 중복 없이 데이터가 입력, 수정, 삭제되어야 합니다.
        - 일관성(Consistency): 모든 시스템에서 데이터가 일관되게 유지되어야 함. 예를 들어, 하나의 시스템에서 데이터를 수정하면, 그 변경 사항이 모든 관련 시스템에서 반영되어야 함.
        - 신뢰성(Reliability): 데이터가 신뢰할 수 있어야 함. 데이터는 정확하고, 누락되지 않고, 시간에 따른 변화가 적절하게 반영되어야 함.
    - 데이터 무결성을 유지하기 위해 데이터베이스에서는 여러 가지 무결성 규칙을 사용함. 예를 들어, 기본 키(primary key), 외래 키(foreign key), 유니크(unique) 제약 조건 등을 사용하여 데이터의 일관성을 보장함.
6. API 키
    - 서버가 앱에게 제공하는 것. 앱에서 요청을 보낼 때 API 키를 함께 보냄. 서버는 이 API 키를 통해 요청이 신뢰할 수 있는 앱에서 온 것임을 확인함.
    - 애플리케이션 간의 통신에 사용하는 고유 식별자로, API를 사용하는 클라이언트가 서버에게 자신을 식별하기 위해 사용함. API 키는 클라이언트가 요청을 보낼 때 헤더나 쿼리 문자열에 포함하여 전송하게 됨.
    - 일반적인 API 키 사용 로직
        1. API 키 생성: 서버 측에서는 각 앱에 대한 고유한 API 키를 생성
        2. API 키 전달: 생성된 API 키는 앱에 전달됨. 앱은 이 API 키를 안전하게 저장해야 함.
        3. API 호출: 앱은 API를 호출할 때마다 이 API 키를 요청 헤더에 포함하여 보냄. 
        4. API 키 검증: 서버는 요청을 받을 때마다 API키를 검증함. API 키가 유효하고 해당 앱의 API 키와 일치하는 경우에만 요청을 처리하고, 그렇지 않은 경우에는 요청을 거부함.
    - API 키 사용 이점
        - 인증: 클라이언트가 API 키를 통해 자신을 식별하므로, 서버는 이를 통해 클라이언트의 신원을 확인할 수 있음.
        - 접근 제어: 서버는 API 키를 기반으로 클라이언트의 접근 권한을 제어할 수 있음. 예를 들어, 특정 API 키를 가진 클라이언트만 특정 API에 접근하도록 설정할 수 있음
        - 요청 추적: 서버는 API 키를 통해 클라이언트의 API 사용 패턴을 추적하고, 이를 기반으로 API의 성능을 모니터링하거나 이용량 제한 등을 설정할 수 있음.
    - API 키 사용 시 주의사항
        - 보안: API 키는 민감한 정보이므로 안전하게 보관해야 함. 만약 API 키가 유출되면, 누군가가 이를 이용하여 악의적인 행위를 할 수 있음.
        - 전송: API 키는 암호화된 채널(예: HTTPS)를 통해 전송되어야 함
        - 저장: API 키는 클라이언트 측에서 안정하게 저장되어야 함. 브라우저의 로컬 스토리지나 모바일 앱의 저장공간 등에 저장할 때는 보안을 고려해야 함.
7. IP 화이트 리스트
    - 서버가 요청을 받을 수 있는 IP 주소를 제한함. 이 경우, 앱이 실행되는 장치의 IP 주소만 요청을 보낼 수 있음
8. 모바일 앱에서 민감한 정보를 저장할 때 고려해야 할 것
    - 암호화: 저장하는 데이터를 암호화하여 보안을 강화할 수 있음. 이를 위해서는 암호화 알고리즘을 사용하여 데이터를 암호화하고, 복호화할 때에만 원래의 데이터를 확인할 수 있도록 해야 함.
    - Secure Storage: 안전한 저장소를 사용해야 함. 안드로이드의 경우 'Keystore' 시스템, iOS의 경우 'Keychain'을 사용하여 키, 비밀번호 등의 민감한 정보를 안전하게 저장할 수 있음.
    - Access Control: 데이터에 접근하는 것을 제어해야 함. 사용자의 인증 상태나 권한에 따라 데이터에 접근할 수 있는지를 제어하는 것이 중요함.
    - Data Minimization: 필요한 최소한의 데이터만 저장해야 함. 사용자의 개인정보나 민감한 정보는 반드시 필요한 경우에만 저장하고, 사용이 끝나면 즉시 삭제하는 것이 좋음.
    - Data Life Cycle Management: 데이터의 생명 주기를 관리해야 함. 데이터의 생성, 사용, 저장, 삭제 등 데이터의 전체 생명 주기 동안 보안을 유지해야 함.