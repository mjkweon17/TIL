## 23년 12월 20일

1. generator 객체
    - 반복 가능한 값을 생성하는 객체
    - 일련의 값들을 순차적으로 생성할 수 있으며, 이를 통해 메모리를 효율적으로 사용하면서 큰 데이터 집합이나 복잡한 연산 결과를 순차적으로 처리할 수 있음
    - 주요 특징
        - Lazy Evaluation(지연 평가): generator는 필요할 때까지 값들을 생성하지 않음. 즉, generator의 다음 값이 필요할 때마다 해당 값만 계산하고 반환함. 이는 메모리 사용을 최적화하고, 큰 데이터 집합이나 계산 집약적인 연산을 효율적으로 처리할 수 있게 함.
        - 'yield' 키워드 사용: generator는 yield 키워드를 사용하여 값을 반환함. 함수 내에서 yield를 사용하면, 함수는 generator를 반환하고, 이 generator는 yield에서 반환한 값들을 순차적으로 생성함
        - 상태 유지: generator는 실행 상태를 유지함. 즉, generator에서 yield를 통해 값을 반환한 후, 다음 값이 요청될 때까지 함수의 상태(지역 변수, 실행 위치 등)가 유지됨. 이렇게 하여, 함수는 중단된 곳에서 다시 실행을 계속할 수 있음
        - 한 번 사용됨: generator는 한 번만 순회할 수 있음. 모든 값이 생성되고 나면, generator는 소진되며, 다시 시작하려면 generator를 새로 생성해야 함.
    - 예제 1
        ```python
        def count_up_to(max):   # 매개변수 max를 받아서 1부터 max까지의 숫자를 순차적으로 생성
            count = 1
            while count <= max:
                # 현재 count값을 밖으로 생성(yield)함. yield는 현재 함수의 실행을 일시 중지하고 값을 반환함. 다음에 제네레이터가 호출될 때, 함수는 yield 다음 줄에서 실행을 재개함.
                yield count 
                count += 1

        # count_up_to(5)를 호출하면 제너레이터 객체 counter가 생성됨. 이 객체는 count_up_to 함수에 의해 생성된 숫자를 순차적으로 제공할 것. 이때, 함수의 코드는 아직 실행되지 않음. 제너레이터는 값이 필요할 때까지 실행을 지연시킴.
        counter = count_up_to(5)
        for num in counter:
            # for 루프를 사용하여 counter 제너레이터를 순회함. 이 때, 제너레이터는 yield에 의해 반환된 다음 값을 생성함.
            # 제너레이터는 yield를 만날 때마다 값을 반환하고 실행을 일시 중지. 다음 값이 필요할 때, 제너레이터는 yield 다음 줄부터 실행을 재개함. 이 과정은 counter가 더 이상 값을 생성할 수 없을 떄까지, 즉 count_up_to 함수의 while루프가 끝날 때까지 게속됨
            print(num)
        
        ```
    - python의 제너레이터에서 return문을 사용하면, 제너레이터가 값을 모두 생성하고 종료될 때 지정된 값을 StopIteration예외와 함께 반환함. 이는 제너레이터가 끝났음을 나타내는 신호로 사용됨. 그러나 이 반환 값은 보통의 방식으로는 직접적으로 접근할 수 없으며, 특별한 처리가 필요함. 또한, 일반적인 사용 시나리오에서는 for 루프나 제너레이터 표현식을 사용하여 제너레이터를 순회할 때 return 값에 접근하지 않음.
2. 시나리오
    - 개발자에게 다양한 의미를 가질 수 있음. 가장 일반적인 해석은 특정 상황이나 시퀀스를 설명하는 스크립트나 계획을 의미. 이는 문제 해결 과정, 사용자 흐름, 이벤트 처리 방식 등 여러 가지를 포함할 수 있음.
    - 효과적인 시나리오를 작성하는 방법
        - 사용자 중심의 접근: 사용자의 관점에서 생각해야 함. 사용자가 어떤 목표를 달성하려고 하는지, 그들이 어떤 경로를 통해 그 목표를 달성하려고 하는지 고려해야 함.
        - 구체적이고 자세한 설명: 효과적ㅈ인 시나리오는 구체적이고 자세한 설명을 포함해야 함. 이는 시스템의 동작 방식, 사용자의 행동, 그리고 그 사이의 상호작용을 명확하게 이해할 수 있게 해줌.
        - 다양한 상황 고려: 모든 가능한 사용자 행동과 시스템 반응을 고려해야 함. 이는 일반적인 흐름뿐만 아니라 예외 상황이나 에러 상황도 포함됨
        - 반복적인 검토와 수정: 시나리오는 한 번에 완벽하게 작성하기 어려움. 시나리오를 작성한 후에는 반복적으로 검토하고 수정해야 함. 이는 시나리오가 실제 사용자 경험과 시스템 동작을 정확하게 반영하도록 하는 데 도움이 됨.
        - 팀원과의 의사소통: 시나리오는 팀원들과 공유되어야 함. 이는 다른 사람들의 피드백을 받고, 더 넓은 시야를 가지게 되는 데 도움이 됨. 
    - 시나리오와 로직의 차이
        - 시나리오는 주로 사용자와 시스템 간의 상호작용을 설명하는 데 사용됨
        - 로직은 내부 동작을 설명하는 데 사용됨
3. 파이썬의 키워드
    - del: 객체를 삭제하는 데 사용됨. 리스트의 특정 요소를 삭제하거나, 변수를 완전히 제거하는 데 사용될 수 있음
    - pass: 아무 것도 하지 않는 코드 블록을 나타냄. 아직 구현되지 않는 코드 부분을 채우는 데 사용됨. 이미 구현된 코드 블록에서는 함수를 구현하는 도중에 임시로 중단하는 경우에 사용하고, 일반적으로 사용하지는 않음.
    - with: 컨텍스트 관리자를 사용하는 데 사용됨. 파일을 열거나, 락을 획득하는 등의 작업을 수행하고, 작업이 완료되면 자동으로 정리하는 데 사용됨
        - 컨텍스트 관리자가 뭐지?
        - 락을 획득한다는 뭐야?
        - 파일을 열 때 어떻게 사용해?
    - global / nonlocal: 변수의 스코프를 조정하는 데 사용됨. global은 변수를 전역 변수로 선언하고, nonlocal은 변수를 바깥쪽 함수의 변수로 선언함.
    - assert: 주로 디버깅 목적으로 사용되며, 특정 조건이 참인지 확인함. 조건이 거짓이면 AssertionError가 발생함
    - lambda: 이름 없는 또는 익명 함수를 정의하는 데 사용됨. 일회성 함수를 만드는 데 유용하며, 주로 filter(), map()등의 함수와 함께 사용됨
        - 예제
        - filter(), map() 등의 함수와 사용되는 이유는?
    - yield from: 제너레이터에서 다른 제너레이터를 사용할 때 사용됨. 이는 중첩된 for 루프를 피하고 코드를 간결하게 만드는 데 도움이 됨
        - 예제
    - 
4. with 키워드
    - 컨텍스트 관리 프로토콜(Context Manager Protocol)을 구현하는 객체와 함께 사용됨. 주로 리소스가 제한된 작업들을 안전하게 처리하는 데 사용됨. 이를 통해 개발자는 리소스의 정리에 대해 고민하지 않고, 실제 로직에 집중할 수 있음
    - with 문을 사용하며 블록 범위의 시작과 끝에서 enter와 exit 메서드를 호출함.
    - with 문이 시작될 때 호출되며, 여기서 필요한 리소스를 할당하거나 초기화함. 이 메서드가 반환하는 값은 with 문의 as 키워드 뒤에 오는 변수에 할당함
    - with 문이 종료될 때 exit 메서드가 호출되며, 리소스를 정리함. 이 메서드는 예외 처리도 담당하며, 예외가 발생하면 이를 인자로 받아서 처리할 수 있음
5. 컨텍스트 관리 프로토콜
    - Context Management Protocol
    - 특정 동작들이 컨텍스트 안에서 실행되도록 정의하는 메커니즘. 이 컨텍스트는 with 키워드를 사용한 코드 블럭을 의미하며, 이 블럭 안에서는 리소스의 할당과 해제, 에외 처리 등의 작업이 수행됨.
    - 컨텍스트 관리 프로토콜을 구현하려면, 클래스에 enter와 exit 두 개의 메서드를 정의해야 함.
    - 예제
        ```python
        class ManagedFile:
            def __init__(self, name):
                self.name = name

            def __enter__(self):
                self.file = open(self.name, 'r')
                return self.file

            def __exit__(self, exc_type, exc_val, exc_tb):
                if self.file:
                    self.file.close()

        with ManagedFile('hello.txt') as f:
            content = f.read()
            print(content)
        ```
6. 락을 획득한다
    - 멀티스레딩 환경에서 사용되는 용어
    - 여러 스레드가 동시에 공유 자원에 접근하는 것을 방지하기 위한 기법 중 하나
    - 락은 상호 배제(Mutex)를 구현하는 코드. 한 번에 하나의 스레드만 특정 코드를 실행하도록 하는 역할을 함. 이를 통해 여러 스레드가 동시에 동일한 리소스에 접근하여 발생할 수 있는 데이터 경쟁 조건을 방지할 수 있음
    - 데이터 일관성을 유지하는 데 중요한 역할을 함
    - 락을 획득하는 과정
        - 스레드가 공유 자원에 접근하려고 할 때, 락을 획득하려고 시도함
        - 락이 이미 다른 스레드에 의해 획득되엇다면, 그 스레드는 락이 해제될 때까지 기다려야 함. 이를 블로킹(blocking)이라고 함
        - 락이 획득 가능하다면, 그 스레드는 락을 획득하고 공유 자원에 접근하여 작업을 수행함
        - 작업이 끝나면, 스레드는 락을 해제(release)함. 이로 인해 다른 스레드들이 락을 획득하고 공유 자원에 접근할 수 있게 함.
7. 스레드
    - 프로세스 내에서 실행되는 흐름의 단위
    - 한 프로세스 내에서 여러 개의 스레드를 생성하여 병렬 처리를 할 수 있음. 이를 통해 여러 작업을 동시에 처리하거나, I/O 작업이 진행되는 동안 다른 작업을 처리하는 등의 효율적인 작업이 가능함
    - 스레드는 각각의 스택을 가지지만, 코드 섹션(code), 데이터 섹션(data), 힙(heap) 등은 공유. 따라서 스레드끼리 데이터를 공유하기 쉽지만, 이로 인해 동기화 문제가 발생할 수 있음
    - 예) 두 스레드가 동시에 같은 데이터를 변경하려고 하는 경우, 데이터의 무결성이 깨질 수 있음
    - 이런 문제를 해결하기 위해 뮤텍스(mutex), 세마포어(semaphore), 모니터(Monitor) 등의 동기화 기법을 사용함
    - 스레드는 멀티코어 또는 멀티프로세서 환경에서 특히 유용하게 사용됨. 각 스레드를 다른 프로세서에서 독립적으로 실행시킴으로써, 프로그램의 실행 속도를 향상시킬 수 있음. 이를 멀티스레딩이라고 함.
8. 백엔드 개발자가 운영체제의 이해를 필요로 하는 이유
    - 성능 최적화: 운영체제의 작동 원리를 이해하면 시스템의 성능을 최적화하는 데 도움이 됨.
        - 예) 프로세스와 스레드의 관리, 메모리 관리, I/O 처리 등에 대한 이해로 성능 향상
    - 리소스 관리: 백엔드 개발은 대부분 서버에서 실행되며, 서버에서는 자원을 효율적으로 사용하는 것이 중요. 운영체제를 이해하면 메모리, CPU, 디스크 등의 리소스를 어떻게 관리하는지 알 수 있음
    - 동시성 및 병렬 처리: 동시에 여러 요청을 처리하거나, 복잡한 작업을 여러 부분으로 나누어 병렬로 처리하는 것은 백엔드 개발에서 중요한 부분. 운영체제는 이런 동시성과 병렬 처리를 어떻게 관리하는지에 대한 이해를 제공함
    - 보안: 운영체제는 시스템의 보안을 유지하는 데 중요한 역할을 함. 사용자 권한 관리, 메모리 보호, 네트워크 보안 등에 대한 이해는 시스템의 보안을 높이는 데 도움이 됨.
9. 프로세스
    - 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
    - 운영체제에서는 프로세스를 각각 독립된 실행 환경으로 관리하며, 각 프로세스는 자신만의 메모리 공간과 자원을 할당받아 사용함
    - 스레드는 이 프로세스 내에서 실행되는 하나의 실행 흐름. 한 프로세스 내에서 여러 스레드를 생성하면, 이들 스레드는 프로세스의 메모리 공간과 자원을 공유하면서 병렬적으로 실행될 수 있음
    - 프로세스와 스레드는 모두 실행 흐름의 단위
    - 프로레스와 스레드의 사용 방식과 특성에 따른 차이
        - 메모리 공간: 프로세스는 각각 독립된 메모리 공간을 가지지만, 스레드는 같은 프로세스 내에서 메모리 공간을 공유함. 이로 인해 스레드간의 통신이 더 간편하지만, 동기화 문제를 주의해야 함
        - 생성 및 관리 비용: 프로세스를 생성하고 관리하는 비용은 스레드에 비해 높음. 따라서 적은 자원으로 동시성을 구현하려면 스레드를 사용하는 것이 효율적
        - 통신 방식: 프로세스 간 통식은 IPC(Inter-Process Communication) 기법을 통해 이루어지며, 복잡한 과정을 거침. 반면 스레드 간 통신은 같은 메모리 공간을 공유하기 때문에 더 간단하고 빠름.
        - 영향 범위: 프로세스 내에서 오류가 발생하면 해당 프로세스만 영향을 받지만, 스레드 내에서 오류가 발생하면 같은 프로세스 내의 다른 스레드도 영향을 받을 수 있음
10. 동기화 문제
    - 멀티스레딩 환경애서 여러 스레드가 공유 자원에 동시에 접근하려 할 때 발생하는 문제. 
    - 대표적인 문제들
        - 경쟁 조건(Rade Condition): 두 개 이상의 스레드가 동시에 공유 데이터에 접근하고, 그 결과가 스레드의 실행 순서에 따라 달라지는 것.
            - 예) 한 스레드가 데이터를 읽어와서 수정하는 도중 다른 스레드가 그 데이터를 변경하면, 첫 번째 스레드는 잘못된 정보를 바탕으로 계산을 하게 됨
        - 교착 상태(Deadlock): 두 개 이상의 스레드가 서로 상대방이 가지고 있는 리소스를 기다리면서 진행을 멈추는 상태.
            - 예) 스레드 A가 락 X를 가지고 잇고 락 Y를 얻기를 기다리는 동안, 스레드 B는 락 Y를 가지고 있고 락 X를 얻기를 기다린다면, 두 스레드는 서로가 가진 락을 놓을 때까지 영원히 기다리게 됨
        - 기아 상태(Starvaion): 특정 스레드가 필요한 리소스를 무한히 얻지 못하고 계속 기다리는 상황. 이는 스케줄링 정책, 리소르 할당 정책 등에 따라 발생할 수 있음