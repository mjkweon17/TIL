## 23년 12월 17일

1. JWT 클레임
    - iss (Issuer): 토큰을 발행한 발행자
    - sub (Subject): 토큰이 속한 주제
    - aud (Audience): 토큰이 전송되는 대상
        - 어떤 서비스나 애플리케이션을 위해 발행되었는지를 나타내는데 사용됨
        - 보통 서비스나 애플리케이션의 고유 식별자를 사용하며, 이는 서비스나 애플리케이션의 도메인 이름, URL, 애플리케이션 ID 등이 될 수 있음.
        - 예) 특정 웹 서비스에서 사용자 인증을 위해 JWT를 발행한 경우 'aud' 클레임에는 해당 웹 서비스의 식별자를 입력할 수 있음.
    - exp (Expiration Time): 토큰의 만료 시간. 이를 통해 토큰의 수명을 제한할 수 있음.
    - nbf (Not Before): 토큰이 활성화되는 날짜/시간을 나타냄. 이 시간 이전에는 토큰이 사용되지 않음.
    - iat (Issued At): 토큰이 발행된 시간을 나타냄.
    - jti (JWT ID): 토큰의 고유 식별자. 이를 통해 토큰을 추적하거나 중복 사용을 방지할 수 있음.
2. access token과 refreh token의 payload
    - 두 토큰은 다른 용도로 사용되기 때문에, 포함되는 정보가 다르게 설정될 수 있음. 따라서 payload에 포함되는 내용이 달라도 괜찮음
    - 액세스 토큰: 일반적으로 사용자 세션을 유지하고, 사용자가 특정 리소스에 접근하는 것을 인증하는 데 사용됨. 따라서 액세스 토큰의 payload에는 이러한 인증에 필요한 정보가 포함됨. 예) 사용자의 ID, 권한, 토큰의 유효 기간 등
    - 리프레시 토큰: 액세스 토큰이 만료되었을 때 새로운 액세스 토큰을 발급받는 데 사용. 리프리세 토큰은 일반적으로 액세스 토큰보다 오랜 시간 동안 유효하며, 리프레시 토큰이 유효한 동안에는 사용자가 로그인 상태를 유지할 수 있음. 리프레시 토큰의 playload에는 이 토큰이 유효한 사용자임을 확인하는데 필요한 최소한의 정보만 포함되면 됨.
3. datetime.now()와 datetime.uctnow()
    - datetime.now(): 시스템의 현재 시간을 로컨 시간으로 반환. 컴퓨터가 설정된 시간대에 따른 현재 시간을 알려줌. 사용자에게 현재 시간을 보여주거나 로컬 이벤트를 스케줄링하는 등 로컬 시간이 중요한 경우 사용.
    - datetime.uctnow(): 현재의 유니버설 시간(UTC, Coordinate Universal Time)을 반환. 이는 시간대에 영향을 받지 않는 표준 시간. 글로벌 이벤트를 스케쥴링하거나 시간대가 다른 사용자간의 데이터를 동기화하는 등 시간대에 영향을 받지 않는 표준 시간이 필요한 경우 사용.
    - 하나의 프로그램에서 두 함수를 혼용해서 사용하는 것은 권장되지 않음. 두 함수는 서로 다른 시간 기준을 가지므로, 이를 혼용하면 프로그램 내에서 시간 관련된 오류나 혼란을 일으킬 수 있음.
        ```python
        # 문제 발생 예시
        from datetime import datetime, timedelta
        local_now = datetime.now()
        utc_now = datetime.utcnow()
        time_diff = local_now - utc_now
        print(time_diff()) # 두 시간대가 다르므로 당연히 큰 차이가 발생
        ```
4. 타입 힌팅
    - 변수, 함수 인자, 반환 값 등의 예상되는 타입을 명시적으로 표기하는 방법
    - 코드를 읽는 사람은 더 이해하기 쉽고, 일부 IDE와 linter는 타입 힌팅을 통해 오류를 더욱 잘 잡아낼 수 있음
    - FastAPI와 SQLAlchemy를 사용하는 경우, Pydantic 모델과 SQLAlchemy 모델이 이미 타입 힌팅을 사용하고 있으므로, 주로 함수의 반환 값에 타입 힌팅을 추가하면 됨
5. 스키마 순서
    - 일반적으로 아래 두 가지 기준으로 나열함
        - 사용 빈도수: 가장 많이 사용되는 스키마를 위쪽에 배치해서 코드를 읽는 사람이 보기 쉽도록 하기
        - 의존성: 한 스키마가 다른 스키마를 필드로 참조하는 경우, 참조되는 스키마를 먼저 정의해야 함.
6. 정규표현식
    - regex="^[a-zA-Z0-9]+$"
        - ^ : 문자열의 시작을 의미
        - [a-zA-Z0-9] : 소문자 a-z, 대문자 A-Z, 그리고 숫자 0-9 중 하나의 문자를 의미
        - + : 앞의 표현식이 하나 이상 반복되는 경우를 의미
        - $ : 문자열의 끝을 의미
    - regex="^[a-zA-Z0-9가-힣]+$"
        - 한글은 유니코드 범위로 표현할 수 있으며 전체 범위는 위와 같이 '가-힣'으로 표현 가능.
7. JWTError
    - 주로 아래의 상황에서 발생
        - 토큰이 만료되었을 때
        - 토큰이 변경되었을 때
        - 토큰이 잘못된 형식일 때
        - 시크릿 키가 잘못되었을 때


====================================================

1. token 관련
    - JWT는 Header, Payload, Signature 세 부분으로 구성됨, 각 부분은 Base64로 인코딩된 문자열. 따라서 실제 데이터에 비해 길이가 길어짐.
    - Payload에서 jti(토큰의 고유 식별자)는 UUID를 사용하므로 토큰의 길이를 길게 하는 원인이 될 수 있음.
    - 토큰의 길이를 줄이려면, 토큰에 포함된 정보의 수를 줄이거나, 정보를 더 간략하게 표현하는 방법을 고려해볼 수 있음. 그러나 이렇게 하면 보안성이나 토큰의 유용성이 줄어들 수 있으므로, 적절한 균형을 찾는 것이 핵심.
2. pydantic 관련
    - model_dump() dict()는 모두 딕셔너리 형태로 만들어 줌. dict()는 중첩된 것들은 딕셔너리로 만들어주지 않지만, model_dump()는 중첩된 모델들도 딕셔너리로 만들어줌. 그래서 model_dump()를 쓰는 게 더 좋을 거 같음. model_dump()안에 exclude_unset=True를 적어주면 설정되지 않은 필드를 결과에서 제외하도록 할 수 있음. 즉, 클라이언트에서 제공하지 않은 필드는 무시하고, 제공한 필드만 딕셔너리로 변경.
3. python 관련
    - setattr()
        - 첫 번째 인수로 제공된 객체의 속성을 설정함
        - setattr(user, key, value): user 객체의 key 속성을 value 값으로 설정함