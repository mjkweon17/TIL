## 23년 12월 9일

1. 패키지
    - aiohttp==3.9.0: 비동기 HTTP 클라이언트/서버 프레임워크입니다. asyncio를 기반으로한 HTTP 작업을 위해 사용됩니다.
    - aiosignal==1.3.1: 비동기 시그널 핸들러 라이브러리입니다. 이 라이브러리는 asyncio를 사용하여 여러 곳에서 사용할 수 있는 시그널을 관리하게 도와줍니다.
    - annotated-types==0.5.0: Python의 타입 힌트를 확장하여 더 많은 정보를 제공하는 라이브러리입니다.
    - anyio==3.7.1: 어떤 이벤트 루프를 사용하더라도 동일한 API를 제공하는 비동기 I/O 프레임워크입니다.
    - async-timeout==4.0.3: asyncio를 사용하여 시간 제한을 설정하는 라이브러리입니다.
    - attrs==23.1.0: Python 클래스를 더 쉽게 다루기 위한 도구입니다. attrs를 사용하면 클래스를 더 간결하게 작성할 수 있습니다.
    - bcrypt==4.0.1: Python에서 BCrypt 해싱 알고리즘을 사용하기 위한 라이브러리입니다.
    - bpyutils==0.5.8: Blender Python API를 쉽게 사용할 수 있도록 돕는 도구 모음입니다.
    - certifi==2023.7.22: Python HTTP 클라이언트에 사용되는 Mozilla의 CA 번들입니다.
    - charset-normalizer==3.3.0: 텍스트 인코딩을 정규화하는 라이브러리입니다. 이 라이브러리는 텍스트의 인코딩을 감지하고 변환하는 데 사용됩니다.
    - click==8.1.3: 명령줄 인터페이스를 구축하는 데 사용되는 Python 라이브러리입니다.
    - colorama==0.4.6: 터미널에 컬러 텍스트를 출력하기 위한 도구입니다.
    - distro==1.8.0: Linux 배포판에 대한 정보를 제공하는 라이브러리입니다.
    - ecdsa==0.18.0: ECDSA 암호화 알고리즘을 구현한 Python 라이브러리입니다.
    - exceptiongroup==1.1.2: 여러 예외를 그룹화하여 처리하는 데 사용되는 라이브러리입니다.
    - fastapi==0.104.1: 현대적이고 빠르며, 고성능 웹 API를 구축하기 위한 프레임워크입니다.
    - frozenlist==1.4.0: 변경할 수 없는 리스트를 구현한 라이브러리입니다.
    - greenlet==2.0.2: 경량 스레딩을 가능하게 하는 라이브러리입니다.
    - h11==0.14.0: HTTP/1.1 프로토콜을 파싱하는 라이브러리입니다.
    - httpcore==1.0.2: HTTP 요청을 처리하기 위한 저수준 라이브러리입니다.
    - httpx==0.25.1: Python에서 HTTP 요청을 보내기 위한 고수준 라이브러리입니다.
    - idna==3.4: Python에서 Internationalized Domain Names in Applications (IDNA)를 지원하기 위한 라이브러리입니다.
    - iniconfig==2.0.0: Python에서 .ini 스타일의 설정 파일을 읽고 작성하는 데 사용되는 라이브러리입니다.
    - install==1.3.5: Python 패키지를 설치하는 도구입니다.
    - Jinja2==3.1.2: Python의 유연한 템플릿 엔진입니다. 웹 페이지를 생성하는 데 사용됩니다.
    - MarkupSafe==2.1.3: Python에서 문자열을 안전하게 처리하기 위한 라이브러리입니다.
    - multidict==6.0.4: key에 대해 여러 값을 가지는 사전형 데이터를 지원하는 라이브러리입니다.
    - mysql==0.0.3와 mysqlclient==2.2.0: Python에서 MySQL 데이터베이스를 사용하기 위한 라이브러리입니다.
    - openai==0.28.0: OpenAI의 API를 사용하기 위한 Python 라이브러리입니다.
    - packaging==23.1: Python에서 패키지 버전을 다루기 위한 라이브러리입니다.
    - passlib==1.7.4: Python에서 다양한 비밀번호 해싱 스킴을 지원하기 위한 라이브러리입니다.
    - pluggy==1.2.0: Python에서 플러그인 메커니즘을 구현하기 위한 라이브러리입니다.
    - pyasn1==0.5.0: Python에서 ASN.1 데이터 구조를 다루기 위한 라이브러리입니다.
    - pycryptodome==3.18.0: Python에서 암호화와 해싱을 위한 라이브러리입니다.
    - pydantic==2.5.2와 pydantic-settings==2.0.2와 pydantic_core==2.14.5: 데이터 검증을 위한 라이브러리입니다. Pydantic은 특히 FastAPI와 함께 사용됩니다.
    - PyJWT==2.8.0: Python에서 JSON Web Token(JWT)를 생성하고 검증하는 데 사용되는 라이브러리입니다.
    - PyMySQL==1.1.0: Python에서 MySQL 데이터베이스를 사용하기 위한 라이브러리입니다.
    - pytest==7.4.0: Python에서 단위 테스트를 작성하고 실행하는 데 사용되는 라이브러리입니다.
    - python-dotenv==1.0.0: Python에서 .env 파일을 사용하여 환경 변수를 설정하는 데 사용되는 라이브러리입니다.
    - python-jose==3.3.0: Python에서 JSON Object Signing and Encryption(JOSE)를 구현하는 라이브러리입니다.
    - python-multipart==0.0.6: Python에서 multipart/form-data를 파싱하는 데 사용되는 라이브러리입니다.
    - requests==2.31.0: Python에서 HTTP 요청을 보내기 위한 라이브러리입니다.
    - rsa==4.9: Python에서 RSA 암호화 알고리즘을 구현하는 라이브러리입니다.
    - six==1.16.0: Python 2와 3의 호환성을 유지하기 위한 라이브러리입니다.
    - sniffio==1.3.0: Python의 비동기 I/O 라이브러리에서 현재 사용 중인 이벤트 루프를 감지하는 라이브러리입니다.
    - SQLAlchemy==2.0.23: Python에서 SQL 데이터베이스를 사용하기 위한 ORM 라이브러리입니다.
    - starlette==0.27.0: 비동기 웹 애플리케이션을 작성하기 위한 경량 웹 프레임워크입니다.
    - tomli==2.0.1: Python에서 TOML 파일을 파싱하는 데 사용되는 라이브러리입니다.
    - tqdm==4.66.1: Python에서 진행 상황 바를 표시하는 데 사용되는 라이브러리입니다.
    - typing_extensions==4.8.0: Python의 타이핑 모듈을 확장하는 라이브러리입니다.
    - urllib3==2.0.6: Python에서 HTTP 요청을 보내는 데 사용되는 라이브러리입니다.
    - uvicorn==0.22.0: ASGI 서버를 구동하기 위한 라이브러리입니다. FastAPI와 함께 사용되는 경우가 많습니다.
    - yarl==1.9.3: URL을 안전하게 다루기 위한 라이브러리입니다.
2. router 폴더
    - router.py: 이 파일은 특정 라우터와 관련된 모든 경로 작업을 정의. FastAPI에서 경로 작업은 특정 HTTP 요청에 응답하는 함수 또는 메소드를 의미.
    - schemas.py: 이 파일은 Pydantic 모델이 정의되는 곳. 이 모델들은 데이터 유효성 검사, 데이터 직렬화/역직렬화, API 문서 자동 생성 등에 사용.
    - models.py: 이 파일에서는 데이터베이스 모델이 정의. 이 모델들은 SQLAlchemy와 같은 ORM(Object Relational Mapping) 라이브러리를 사용하여 데이터베이스와의 상호작용을 추상화.
    - dependencies.py: 이 파일은 의존성을 정의하고 관리하는 곳. 의존성은 경로 작업 함수에서 재사용 가능한 부분을 분리하는 데 도움이 됨.
    - config.py: 이 파일은 로컬 설정을 관리. 예를 들어, 데이터베이스 연결 정보나 환경 변수 등이 이 파일에 저장될 수 있음.
    - constants.py: 이 파일은 프로젝트 전체에서 사용되는 상수를 정의하는 곳.
    - exceptions.py: 이 파일은 프로젝트에서 발생할 수 있는 사용자 정의 예외를 정의하는 곳. 이를 통해 에러 처리를 일관성 있게 관리할 수 있음.
    - service.py: 이 파일은 비즈니스 로직이 구현되는 곳. 데이터 처리, 알고리즘 적용 등의 작업을 수행하는 함수나 클래스를 이 파일에 작성.
    - utils.py: 이 파일은 프로젝트 전체에서 재사용 가능한 헬퍼 함수나 유틸리티 함수를 정의하는 곳.
3. 데이터 직렬화/역직렬화
    - data Serialization / Deserialization
    - 직렬화
        - 메모리에 있는 데이터 구조나 객체 상태를 저장하거나 네트워크를 통해 전송할 수 있는 형식(주로 문자열)으로 변환하는 과정
        - 예를 들어 파이썬 객체를 JSON 형식의 문자열로 변환하는 것이 직렬화 과정
    - 역직렬화
        - 저장되었거나 전송받은 데이터를 원래의 데이터 구조나 객체 상태로 복원하는 과정
        - 예를 들어 JSON 형식의 문자열을 파이썬 객체로 변환하는 것이 역직렬화 과정
        - 주의할 점은, 역직렬화 과정에서는 신뢰할 수 없는 데이터에 대해 적절한 보안 조치를 취해야 한다는 것. 왜냐하면 악의적인 사용자가 공격 코드를 포함한 데이터를 전송하여 시스템을 공격하는 경우가 있을 수 있기 때문.
4. 비즈니스 로직
    - 어플리케이션의 핵심 기능을 구현하는 코드
    - 사용자의 요청을 처리하고 데이터를 생성, 조회, 업데이트, 삭제하는 등의 작업을 수행
    - 예를 들어, 은행 애플리케이션에서는 계좌 이체, 잔액 조회 등의 기능이 비즈니스 로직에 해당. 이러한 로직은 은행의 규칙(예: 계좌 이체 시 이체 금액이 계좌 잔액을 초과할 수 없음)을 코드로 표현한 것.
    - 주로 서비스 계층(Service Layer) 또는 도메인 계층(Domain Layer)에서 구현. 이곳에서는 사용자 인터페이스나 데이터 접근 로직과는 독립적으로 비즈니스 규칙을 처리하기 때문에, 같은 비즈니스 로직을 여러 인터페이스(웹, 모바일 등)에서 재사용할 수 있음. 이렇게함으로써 코드의 중복을 줄이고 유지보수를 용이하게 함.
5. 헬퍼 함수 / 유틸리티 함수
    - 주로 코드의 재사용성을 높이기 위해 사용되는 함수들. 특정 기능을 수행하는 코드를 모듈화하여 여러 곳에서 재사용할 수 있게 만들어 줌.
    - 헬퍼 함수
        - 주로 특정 기능을 수행하거나 특정 계산을 수행하는 함수
        - 코드 내에서 반복적으로 발생하는 패턴을 추상화하거나, 복잡한 연산을 단순화하는데 도움을 줌
        - 예를 들어, 날짜 형식 변환, 데이터 유효성 검사, 복잡한 문자열 조작 등의 작업을 수행하는 함수
    - 유틸리티 함수
        - 프로젝트 전반에 걸쳐 재사용되는 함수
        - 일반적으로 프로젝트에 특화되지 않은, 범용적인 기능을 수행
        - 배열을 정렬하는 함수, 숫자를 반올림하는 함수 등
6. 환경변수
    - 환경 변수 파일에 기록된 값을 표현식으로 저장하고 이를 파이썬에서 직접 계산하도록 하는 것은 일반적으로 권장되지 않음
    - 환경 변수는 보통 문자열 형식으로 저장되며, 이를 수식으로 해석하려면 추가적인 파싱 작업이 필요하기 때문. 이러한 작업은 보안 문제를 일으킬 수 있으며 코드의 복잡성을 높일 수 있음
    - 환경 변수는 보통 설정 값이나 비밀 키와 같은 정적인 값에 사용되므로, 이를 동적으로 계산하는 것은 일반적이지 않음. 따라서 가능하면 환경 변수에는 계산된 값을 직접 저장하는 것을 권장.
7. OAuth2PasswordRequestForm
    - OAuth2 패스워드 플로우를 지원하기 위한 것
    - client_id: OAuth2에서 클라이언트 애플리케이션을 식별하는 데 사용되는 고유한 식별자
    - client_secret: 클라이언트 애플리케이션의 신원을 확인하는 데 사용
    - scope: 애플리케이션이 사용자의 계정에 액세스할 수 있는 권한의 범위를 정의함
8. PKCE
    - Proof Key for Code Exchange
    - 발음: pixy
    - OAuth 2.0 보안 확장
    - 모바일 애플리케이션을 위해 만들어졌지만, 웹 애플리케이션에도 사용됨
    - PKCE는 공개 클라이언트(예: 네이티브 앱, SPA)에서 발생할 수 있는 인가 코드 인터셉트 공격을 방지
    - 작동 방식
        - 클라이언트는 먼저 랜덤 문자열(코드 검증기, code_verifier)를 생성함. 이 문자열은 클라이언트에서 비공개로 유지됨.
        - 클라이언트는 이 코드 검증기를 해싱하여 코드 도전(code_challenge)을 생성함.
        - 클라이언트는 인가 요청을 보낼 때 이 코드 도전과 함께 code_challenge_method를 전송함. code_challenge_method는 코드 도전이 어떻게 생성되었는지를 명시합니다(SHA256 또는 plain)
        - 사용자가 인증을 완료하면, 인가 서버는 인가 코드를 클라이언트에게 전송함.
        - 클라이언트는 인가 코드와 원래 생성했던 코드 검증기를 사용하여 토큰 요청을 보냄.
        - 인가 서버는 클라이언트가 제공한 코드 검증기를 해싱하고 이를 이전에 저장한 코드 도전과 비교함. 일치하면 액세스 토큰을 발급함.
    - 이 과정을 통해, 인가 코드가 도난당하더라도 악의적인 공격자는 액세스 토큰을 얻을 수 없음. 왜냐하면 액세스 토큰을 얻기 위해서는 원래의 코드 검증기가 필요하기 때문.
9. API 사용량 추적
    - 방법
        - 미들웨어(Middleware) 사용: FastAPI에는 Starlette의 미들웨어 기능이 포함되어 있습니다. 미들웨어는 API 요청과 응답을 가로채는 기능을 가지며, 이를 통해 API 호출에 대한 로그를 기록하거나, 특정 API 키로 이루어진 요청 횟수를 카운트하는 등의 작업을 수행할 수 있습니다.
        - 로깅(Logging) 시스템 활용: Python의 내장 로깅 시스템을 사용하여 API 호출에 대한 정보를 로그로 기록할 수 있습니다. 로그에는 어떤 API가 언제, 어떤 클라이언트에 의해 호출되었는지 등의 정보가 포함될 수 있습니다.
        - 서드파티 모니터링 도구 활용: Datadog, New Relic 등의 서드파티 모니터링 도구를 사용하면 API 사용량을 보다 편리하게 추적하고 분석할 수 있습니다. 이런 도구들은 대부분 사용량 대시보드, 알림 기능 등을 제공하며, FastAPI와 잘 호환됩니다.
    - 이런 방법들을 통해 API 사용량을 추적하면, 어떤 클라이언트가 어떤 API를 얼마나 자주 호출하는지, API 사용 패턴이 어떻게 변하는지 등의 정보를 얻을 수 있습니다. 이 정보를 바탕으로 API 성능을 개선하거나, 서비스를 사용하는 클라이언트에게 더 나은 경험을 제공할 수 있습니다.
10. middleware
    -  웹 애플리케이션과 네트워크 사이에서 동작하는 소프트웨어
    - HTTP 요청과 응답을 처리하는 데 사용됨
    - 웹 애플리케이션의 요청-응답 사이클에서 미들웨어는 중심적인 역할을 함
    - 미들웨어가 할 수 있는 일
        - 요청 또는 응답을 기록한다.
        - 요청을 검사하고 필요한 경우 수정
        - 요청이나 응답에 대한 정보를 수집
        - 보안을 위해 특정 헤더를 확인
        - 요청이나 응답을 압축 또는 암호화
11. FastAPI의 middleware
    - FastAPI의 미들웨어는 특정한 작업을 수행하기 위해 미리 정의된 함수나 메소드를 사용함. 이는 요청이 들어오면 먼저 미들웨어에 의해 처리되고, 그 다음에 실제 웹 애플리케이션의 라우터(특정 경로에 대한 요청 처리기)나 다른 요청 처리기에 전달됨.
    -  app.middleware 데코레이터를 사용하여 정의할 수 있음
    - 미들웨어 함수는 항상 Request 객체와 'call_next' 함수를 매개변수로 받음. 'call_next' 함수는 요청을 다음 미들웨어 또는 라우터로 전달하는 역할을 함. 이 함수는 Response 객체를 반환하며, 이 객체는 미들웨어에서 수정할 수 있음.
    - FastAPI에서 미들웨어는 일반적으로 전역적으로 적용됨.  즉, 미들웨어는 애플리케이션의 모든 라우터와 경로에 적용됨. 그러나 FastAPI는 애플리케이션을 여러 개의 하위 애플리케이션으로 나눌 수 있음. 이때 각 하위 애플리케이션은 자체적인 미들웨어를 가질 수 있음. 따라서 특정 라우터 파일에만 미들웨어를 적용하려면, 해당 라우터를 포함하는 하위 애플리케이션에 미들웨어를 적용하면 됨.
    - @app.middleware("http")
        - FastAPI는 현재 "http"와 "websocket" 두 가지 타입의 미들웨어를 지원함
        - "http"는 HTTP 요청과 응답을 처리
        - "websocket"은 웹소켓 연결을 처리함
    - 특정 경로에서는 미들웨어를 건너뛰도록 설정하는 것
        - 아래의 방법들은 미들웨어의 전역적인 적용을 회피하는 방법으로, FastAPI의 기본 기능을 벗어난 부분이므로 주의해서 사용해야 함
        - 경로에서 미들웨어의 조건을 확인: 미들웨어 함수 내에서 현재 요청의 경로를 확인하고, 특정 경로에 대해서는 미들웨어의 동작을 건너뛸 수 있음
            ```python
            @app.middleware("http")
            async def skip_middleware_for_specific_path(request: Request, call_next):
                if request.url.path != "/specific_path":
                    # 미들웨어의 동작
                response = await call_next(request)
                return response
            ```
        - 미들웨어 대신 데코레이터 사용: 미들웨어와 비슷한 기능을 하는 데코레이터를 만들고, 이를 필요한 경로에만 적용할 수 있음. 이렇게 하면 데코레이터가 적용된 경로에서만 특정 로직이 실행됨
            ```python
            def custom_decorator(func):
                async def wrapper(*args, **kwargs):
                    # 여기에 미들웨어와 비슷한 로직을 적용
                    return await func(*args, **kwargs)
                return wrapper

            @app.get("/specific_path")
            @custom_decorator
            async def specific_path():
                ...
            ```
12. decorator
    - 파이썬의 고급 기능 중 하나
    - 다른 함수를 수정하지 않고 그 기능을 확장할 수 있는 기능
    - 데코레이터는 '@' 기호와 함께 사용되며, 데코레이터 바로 아래에 위치한 함수에 적용됨
    - 함수를 인자로 받아서 새로운 함수를 반환하는 함수. 반환되는 새로운 함수는 원래의 함수를 감싸서 (또는 장식해서) 추가적인 기능을 제공. 이 새로운 함수를 '래퍼(wrapper)' 함수라고 부름.
    - 데코레이터를 사용하면 기존 함수를 수정하지 않고도 그 기능을 확장할 수 있음. 이는 코드의 재사용성을 높이고, 코드의 가독성을 향상시키는 데 유용.
    - 간단한 예제
        ```python
        def my_decorator(func):
        def wrapper():
            print("Before function call")
            func()
            print("After function call")
        return wrapper

        @my_decorator
        def say_hello():
            print("Hello!")
        ```


router.py: 이 파일에는 인증과 관련된 경로 작업을 정의합니다. 예를 들어 로그인, 로그아웃, 비밀번호 변경 등의 API 엔드포인트를 이 파일에 정의할 수 있습니다.
schemas.py: Pydantic 모델을 사용해 API 요청과 응답에 사용되는 데이터의 형식을 정의합니다. 예를 들어, 로그인 요청에 필요한 이메일과 비밀번호, 회원가입 요청에 필요한 사용자 정보 등을 이 파일에서 정의할 수 있습니다.
models.py: 사용자 정보를 저장하는 데이터베이스 모델을 정의하는 곳입니다. 사용자 ID, 이메일, 비밀번호 해시 등이 포함될 수 있습니다.
dependencies.py: 인증에 필요한 의존성을 정의합니다. 예를 들어, 로그인한 사용자의 정보를 가져오는 기능이나, 사용자의 인증 상태를 확인하는 기능 등을 이 파일에서 정의할 수 있습니다.
config.py: 인증과 관련된 설정을 저장하는 곳입니다. 예를 들어, JWT 토큰의 유효 기간, 비밀 키 등이 이 파일에 저장될 수 있습니다.
constants.py: 인증과 관련된 상수를 정의하는 곳입니다. 예를 들어, 토큰의 유형이나 인증에 사용되는 HTTP 헤더의 이름 등이 이 파일에 정의될 수 있습니다.
exceptions.py: 인증과 관련된 사용자 정의 예외를 정의하는 곳입니다. 예를 들어, 인증 실패, 권한 없음 등의 예외를 이 파일에서 정의할 수 있습니다.
service.py: 인증과 관련된 비즈니스 로직을 정의하는 곳입니다. 예를 들어, 사용자의 비밀번호를 검증하거나, JWT 토큰을 생성/검증하는 로직 등이 이 파일에 구현될 수 있습니다.
utils.py: 인증과 관련된 헬퍼 함수나 유틸리티 함수를 정의하는 곳입니다. 예를 들어, 비밀번호를 해시하는 함수, JWT 토큰을 디코딩하는 함수 등이 이 파일에 정의될 수 있습니다.