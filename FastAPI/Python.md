



### setattr()
- 첫 번째 인수로 제공된 객체의 속성을 설정함
- setattr(user, key, value): user 객체의 key 속성을 value 값으로 설정함


### 파이썬의 특별한 메소드
- __init__: 객체가 생성될 때 호출되는 초기화 메소드. 여기에서는 객체의 속성을 설정하는 등의 초기화 작업을 수행.
- __repr__: 객체의 '공식적인' 문자열 표현을 반환. 가능하면 이 메소드가 반환하는 문자열을 `eval()` 함수에 전달하면 원래의 객체가 생성되는 문자열이어야 함.
- __str__객체의 '비공식적인' 또는 '사용자 친화적인' 문자열 표현을 반환함. `str()` 함수나 `print()` 함수는 이 메소드를 호출함.
- __eq__: 두 객체의 동등성을 검사하는 메소드. `==` 연산자는 이 메소드를 호출함.
- __len__: 객체의 '길이'를 반환하는 메소드. `len()` 함수는 이 메소드를 호출함. 
- __getitem__, __setitem__: 객체를 리스트나 딕셔너리처럼 다루도록 해주는 메소드들. `obj[key]` 구문은 `__getitem__`을, `obj[key] = value` 구문은 `__setitem__`을 호출함. 
- __iter__: 객체를 반복 가능하게 해주는 메소드. `iter()` 함수는 이 메소드를 호출하며, 이 메소드가 구현되어 있으면 객체를 `for` 루프에 사용할 수 있음.

### __repr__
- repr은 representation의 줄임말. 레프알 메소드 또는 리프알 메소드라고 읽음.
- 파이썬의 특별한 메소드
- 객체를 나타내는 공식적인 문자열을 반환함
- repr() 내장 함수에 의해 호출되며, 디버깅을 위한 출력이나 로깅, 객체의 비교 등에 사용됨

### repr 함수
- 객체의 인쇄 가능한 표현을 문자열로 반환하는 데 사용
- 객체를 개발자가 이해할 수 있는 형태로 표현하기 위해 사용되며, 주로 디버깅과 로깅 목적으로 활용
- 이 메서드는 클래스의 인스턴스를 나타내는 공식적인 문자열을 제공하여, 인스턴스의 주요 정보를 명확하게 전달할 수 있도록 함
- 클래스 내에서 `__repr__` 매직 메서드를 정의함으로써, 해당 클래스의 인스턴스를 `repr()` 함수를 사용해 호출했을 때 반환할 문자열을 사용자 정의할 수 있음
- 예
    ```python
    class Terms(Base):
    __tablename__ = 'Terms'
    terms_id = Column(INTEGER(11), primary_key=True, autoincrement=True)
    title = Column(Text, nullable=False)
    is_active = Column(Boolean, nullable=False, server_default=text("1"))

    def __repr__(self):
        return f"<Terms(terms_id={self.terms_id}, title={self.title}, is_active={self.is_active})>"
    ```
    - `__repr__` 메서드는 `Terms` 인스턴스의 `terms_id`, `title`, 그리고 `is_active` 속성을 포함하는 문자열을 반환
    - 해당 객체의 상태를 명확하게 파악할 수 있게 해줌
    - 예를 들어 `Terms` 인스턴스를 만들고 이를 출력할 경우, 다음과 같은 형태의 문자열이 반환됨
        - <Terms(terms_id=1, title='이용 약관', is_active=True)>
        - 이 문자열은 객체의 주요 속성과 그 값들을 보여주므로, 객체의 현재 상태에 대한 명확한 이해를 도움



### 파이썬의 주요 기능
- 동적 타이핑: 파이썬은 변수의 타입을 실행 시점에 결정하는 동적 타이핑 언어. 이는 코드를 보다 간결하게 작성할 수 있게 해주지만, 오류를 찾아내는 데는 어려움을 줄 수 있음.
- 객체 지향 프로그래밍: 클래스와 인스턴스, 상속, 다형성 등 객체 지향 프로그래밍의 핵심 요소를 모두 지원함.
- 함수형 프로그래밍: lambda 함수, map과 reduce 등의 고차 함수, 리스트 컴프리헨션 등 함수형 프로그래밍 기능도 지원
- 모듈과 패키지: 코드를 모듈로 분리하고, 모듈들을 패키지로 묶어 관리할 수 있음. 또한, 파이썬의 표준 라이브러리와 수많은 외부 패키지를 쉽게 사용할 수 있음.
- 예외 처리: try/except 블록을 이용한 예외 처리를 지원. 이를 통해 예상치 못한 오류가 발생했을 때도 프로그램이 적절히 대응할 수 있음.
- 코루틴과 비동기 프로그래밍: async/await 문법을 이용하여 비동기 프로그래밍을 지원함. 이를 통해 I/O 바운드 작업을 효율적으로 처리할 수 있음.
- 데코레이터: 함수나 클래스의 기능을 확장하거나 수정하는 데 사용할 수 있는 데코레이터를 지원함.
- 타입 힌트와 제네릭 타이핑: 파이썬 3.5 이후로 변수, 함수, 클래스 등의 타입을 명시적으로 지정할 수 있는 타입 힌트 기능을 지원함. 제네릭 타이핑은 이 타입 힌트 기능의 일부로, 코드의 재사용성과 타입 안전성을 높여줌.

### **kwargs
- 함수에 임의의 개수의 키워드 인자를 전달할 수 있게 해주는 문법
- kwtword arguments의 줄임말이며 관습적인 이름
- **연산자는 인자들을 딕셔너리로 묶어줌
- 객체를 생성할 때 \*\*kwargs를 사용하는 경우는, self.model(**kwargs)와 같이, 클래스의 생성자에 여러 개의 키워드 인자를 전달해야 할 때
- 아래 코드를 실행하면 kwargs 딕셔너리에 {'name': '홍길동'...}과 같이 저장되고, 이 딕셔너리의 각 항목을 순회하면서 키와 값을 출력함
    ```python
    def print_info(**kwargs):
        for key, value in kwargs.items():
            print(f"{key}: {value}")

    print_info(name="홍길동", age=30, city="서울")
    ```



### C Library
- C 라이브러리는 C 프로그래밍 언어로 작성된 코드 모음. 
- 이 라이브러리들은 특정 기능을 수행하기 위한 함수, 자료구조, 변수 등을 제공함. 
- C 라이브러리는 효율성과 성능이 우수하기 때문에 널리 사용되고 있음.
- 파이썬에서는 ctypes나 CFFI와 같은 모듈을 사용하여 C 라이브러리를 로드하고 호출할 수 있음. 
- 이를 통해 파이썬 코드에서 C 라이브러리의 함수를 직접 사용할 수 있게 됨.
- 장점
    - 성능 향상: C로 작성된 코드는 파이썬보다 빠르게 실행되므로, 계산 집약적인 작업에 유용함.
    - 기존 코드 활용: 이미 C로 작성된 라이브러리를 파이썬에서 사용할 수 있어 코드 재사용성이 높아짐.
    - 저수준 시스템 제어: C 라이브러리를 통해 하드웨어나 운영 체제에 직접 액세스할 수 있음.
- 하지만 C 라이브러리를 사용할 때는 메모리 관리와 같은 저수준 문제를 직접 다뤄야 하므로 주의가 필요함.
- 대표적인 C 라이브러리로는 stdio.h, math.h, string.h 등이 있으며, 파이썬의 표준 라이브러리 중 일부도 내부적으로 C로 구현되어 있음.

### os로 환경변수 파일 읽기
```python
dotenv_path = os.path.join(os.path.dirname(__file__), '.env')
```
- __file__
    - 현재 스크립트의 파일명을 포함한 전체 경로를 나타냄
- os.path.dirname(__file)
    - __file__의 디렉토리 경로를 반환함.
- os.path.join(...)
    - 주어진 경로들을 운영 체제에 맞는 파일 경로 구분자로 결합함
    - .env 파일이 이 코드가 작성된 파일과 같은 디렉토리에 위치한다고 가정하면, .env파일의 전체 디렉토리가 됨.

### SyntaxError: positional argument follows keyword argument
- 파이썬의 함수 호출 규칙을 위반했을 때 발생
- 파이썬에서는 위치 인자(positional argument)가 키워드 인자(keyword argument) 뒤에 올 수 없음

### 위치 인자, 키워드 인자
- 위치 인자
    - positional argument
    - 함수를 호출할 때 순서대로 전달하는 방식
    - 함수 정의에서 인자의 순서와 함수를 호출할 때 전달하는 인자의 순서가 일치해야 함
- 키워드 인자
    - keyword argument
    - 함수를 호출할 때 인자의 이름을 명시적으로 지정하여 전달하는 방식
    - 이 방식을 사용하면 인자의 순서는 중요하지 않음
- 위치 인자와 키워드 인자를 혼합해서 사용할 수도 있지만, 위치 인자가 키워드 인자 앞에 와야한다는 규칙이 있음

### 파이썬의 키워드
- del: 객체를 삭제하는 데 사용됨. 리스트의 특정 요소를 삭제하거나, 변수를 완전히 제거하는 데 사용될 수 있음
- pass: 아무 것도 하지 않는 코드 블록을 나타냄. 아직 구현되지 않는 코드 부분을 채우는 데 사용됨. 이미 구현된 코드 블록에서는 함수를 구현하는 도중에 임시로 중단하는 경우에 사용하고, 일반적으로 사용하지는 않음.
- with: 컨텍스트 관리자를 사용하는 데 사용됨. 파일을 열거나, 락을 획득하는 등의 작업을 수행하고, 작업이 완료되면 자동으로 정리하는 데 사용됨
    - 컨텍스트 관리자가 뭐지?
    - 락을 획득한다는 뭐야?
    - 파일을 열 때 어떻게 사용해?
- global / nonlocal: 변수의 스코프를 조정하는 데 사용됨. global은 변수를 전역 변수로 선언하고, nonlocal은 변수를 바깥쪽 함수의 변수로 선언함.
- assert: 주로 디버깅 목적으로 사용되며, 특정 조건이 참인지 확인함. 조건이 거짓이면 AssertionError가 발생함
- lambda: 이름 없는 또는 익명 함수를 정의하는 데 사용됨. 일회성 함수를 만드는 데 유용하며, 주로 filter(), map()등의 함수와 함께 사용됨
    - 예제
    - filter(), map() 등의 함수와 사용되는 이유는?
- yield from: 제너레이터에서 다른 제너레이터를 사용할 때 사용됨. 이는 중첩된 for 루프를 피하고 코드를 간결하게 만드는 데 도움이 됨

### generator 객체
- 반복 가능한 값을 생성하는 객체
- 일련의 값들을 순차적으로 생성할 수 있으며, 이를 통해 메모리를 효율적으로 사용하면서 큰 데이터 집합이나 복잡한 연산 결과를 순차적으로 처리할 수 있음
- 주요 특징
    - Lazy Evaluation(지연 평가): generator는 필요할 때까지 값들을 생성하지 않음. 즉, generator의 다음 값이 필요할 때마다 해당 값만 계산하고 반환함. 이는 메모리 사용을 최적화하고, 큰 데이터 집합이나 계산 집약적인 연산을 효율적으로 처리할 수 있게 함.
    - 'yield' 키워드 사용: generator는 yield 키워드를 사용하여 값을 반환함. 함수 내에서 yield를 사용하면, 함수는 generator를 반환하고, 이 generator는 yield에서 반환한 값들을 순차적으로 생성함
    - 상태 유지: generator는 실행 상태를 유지함. 즉, generator에서 yield를 통해 값을 반환한 후, 다음 값이 요청될 때까지 함수의 상태(지역 변수, 실행 위치 등)가 유지됨. 이렇게 하여, 함수는 중단된 곳에서 다시 실행을 계속할 수 있음
    - 한 번 사용됨: generator는 한 번만 순회할 수 있음. 모든 값이 생성되고 나면, generator는 소진되며, 다시 시작하려면 generator를 새로 생성해야 함.
- 예제
    ```python
    def count_up_to(max):   # 매개변수 max를 받아서 1부터 max까지의 숫자를 순차적으로 생성
        count = 1
        while count <= max:
            # 현재 count값을 밖으로 생성(yield)함. yield는 현재 함수의 실행을 일시 중지하고 값을 반환함. 다음에 제네레이터가 호출될 때, 함수는 yield 다음 줄에서 실행을 재개함.
            yield count 
            count += 1

    # count_up_to(5)를 호출하면 제너레이터 객체 counter가 생성됨. 이 객체는 count_up_to 함수에 의해 생성된 숫자를 순차적으로 제공할 것. 이때, 함수의 코드는 아직 실행되지 않음. 제너레이터는 값이 필요할 때까지 실행을 지연시킴.
    counter = count_up_to(5)
    for num in counter:
        # for 루프를 사용하여 counter 제너레이터를 순회함. 이 때, 제너레이터는 yield에 의해 반환된 다음 값을 생성함.
        # 제너레이터는 yield를 만날 때마다 값을 반환하고 실행을 일시 중지. 다음 값이 필요할 때, 제너레이터는 yield 다음 줄부터 실행을 재개함. 이 과정은 counter가 더 이상 값을 생성할 수 없을 떄까지, 즉 count_up_to 함수의 while루프가 끝날 때까지 게속됨
        print(num)
    
    ```
- python의 제너레이터에서 return문을 사용하면, 제너레이터가 값을 모두 생성하고 종료될 때 지정된 값을 StopIteration예외와 함께 반환함. 이는 제너레이터가 끝났음을 나타내는 신호로 사용됨. 그러나 이 반환 값은 보통의 방식으로는 직접적으로 접근할 수 없으며, 특별한 처리가 필요함. 또한, 일반적인 사용 시나리오에서는 for 루프나 제너레이터 표현식을 사용하여 제너레이터를 순회할 때 return 값에 접근하지 않음.

### with 키워드
- 컨텍스트 관리 프로토콜(Context Manager Protocol)을 구현하는 객체와 함께 사용됨. 주로 리소스가 제한된 작업들을 안전하게 처리하는 데 사용됨. 이를 통해 개발자는 리소스의 정리에 대해 고민하지 않고, 실제 로직에 집중할 수 있음
- with 문을 사용하며 블록 범위의 시작과 끝에서 enter와 exit 메서드를 호출함.
- with 문이 시작될 때 호출되며, 여기서 필요한 리소스를 할당하거나 초기화함. 이 메서드가 반환하는 값은 with 문의 as 키워드 뒤에 오는 변수에 할당함
- with 문이 종료될 때 exit 메서드가 호출되며, 리소스를 정리함. 이 메서드는 예외 처리도 담당하며, 예외가 발생하면 이를 인자로 받아서 처리할 수 있음

### 컨텍스트 관리 프로토콜
- Context Management Protocol
- 특정 동작들이 컨텍스트 안에서 실행되도록 정의하는 메커니즘. 이 컨텍스트는 with 키워드를 사용한 코드 블럭을 의미하며, 이 블럭 안에서는 리소스의 할당과 해제, 에외 처리 등의 작업이 수행됨.
- 컨텍스트 관리 프로토콜을 구현하려면, 클래스에 enter와 exit 두 개의 메서드를 정의해야 함.
- 예제
    ```python
    class ManagedFile:
        def __init__(self, name):
            self.name = name

        def __enter__(self):
            self.file = open(self.name, 'r')
            return self.file

        def __exit__(self, exc_type, exc_val, exc_tb):
            if self.file:
                self.file.close()

    with ManagedFile('hello.txt') as f:
        content = f.read()
        print(content)
    ```

### Docstring
- 문서화 문자열
- 함수, 클래스, 모듈 또는 메소드의 첫 번째 문장으로 포함되는 멀티라인 문자열
- 해당 코드의 기능을 설명하고, 사용 방법, 인자, 반환 값 등을 문서화하는 데 사용됨
- help() 함수를 통해 docstring을 볼 수 있음
- 다양한 도구들이 이를 사용하여 자동 문서를 생성함
- docstring을 첫 번째 문장으로 포함시키는 이유는 파이썬이 이를 자동으로 감지하고, htlp()함수나 다양한 자동 문서화 도구를 통해 사용자가 이 정보를 쉽게 조회할 수 있게 하기 위함
- 들어가면 좋은 거
    - 함수의 목적, 매개변수 설명(Args), 반환 값(Returns), 에러/예외(Raises), 사용 예제(Example), 관련 사항(Note)

### multiline string
- 멀티라인 문자열
- 여러 줄에 걸친 텍스트를 표현하는 데 사용됨
- 일반적인 문자열과 같이 작동하지만, 여러 줄에 걸쳐 텍스트를 포함할 수 있다는 점이 특징
- 세 개의 따옴표를 사용하여 생성됨
- 문자열 안에 개행이 포함되어 있어 여러 줄에 걸친 텍스트를 쉽게 포함할 수 있음
- 주로 큰 덩어리의 텍스트를 저장하거나 멀티라인 주석으로 사용됨

### % 포매팅 vs f-string 포매팅
- 파이썬 3.6 이상에서는 f-string 방식을 권장
- % 포매팅
    - 전통적인 C 스타일의 문자열 포매팅 방식
    - %s와 같은 플레이스홀더를 사용하여 변수를 문자열에 삽입
    - 코드가 길어지거나 변수가 많아질 경우 가독성이 떨어질 수 있음
    - 더 이상 권장되지 않는 방식
- f-string 포매팅
    - 파이썬 3.6 이상에서 사용 가능한 방식
    - {} 안에 직접 변수 이름을 작성하여 문자열에 삽입할 수 있음
    - 가독성이 좋고, 실행 속도도 빠름

### datetime.now()와 datetime.uctnow()
- datetime.now(): 시스템의 현재 시간을 로컨 시간으로 반환. 컴퓨터가 설정된 시간대에 따른 현재 시간을 알려줌. 사용자에게 현재 시간을 보여주거나 로컬 이벤트를 스케줄링하는 등 로컬 시간이 중요한 경우 사용.
- datetime.uctnow(): 현재의 유니버설 시간(UTC, Coordinate Universal Time)을 반환. 이는 시간대에 영향을 받지 않는 표준 시간. 글로벌 이벤트를 스케쥴링하거나 시간대가 다른 사용자간의 데이터를 동기화하는 등 시간대에 영향을 받지 않는 표준 시간이 필요한 경우 사용.
- 하나의 프로그램에서 두 함수를 혼용해서 사용하는 것은 권장되지 않음. 두 함수는 서로 다른 시간 기준을 가지므로, 이를 혼용하면 프로그램 내에서 시간 관련된 오류나 혼란을 일으킬 수 있음.
    ```python
    # 문제 발생 예시
    from datetime import datetime, timedelta
    local_now = datetime.now()
    utc_now = datetime.utcnow()
    time_diff = local_now - utc_now
    print(time_diff()) # 두 시간대가 다르므로 당연히 큰 차이가 발생
    ```

### 타입 힌팅
- 변수, 함수 인자, 반환 값 등의 예상되는 타입을 명시적으로 표기하는 방법
- 코드를 읽는 사람은 더 이해하기 쉽고, 일부 IDE와 linter는 타입 힌팅을 통해 오류를 더욱 잘 잡아낼 수 있음
- FastAPI와 SQLAlchemy를 사용하는 경우, Pydantic 모델과 SQLAlchemy 모델이 이미 타입 힌팅을 사용하고 있으므로, 주로 함수의 반환 값에 타입 힌팅을 추가하면 됨

### 제네릭 타입 힌트
- 파이썬의 타입 힌트 시스템에서 제공하는 기능
- 변수, 함수, 클래스 등이 다루는 데이터의 타입을 보다 유연하게 지정할 수 있게 해줌
- 제네릭 타입 힌트의 기본 개념: 타입 매개변수. 타입 매개변수는 일종의 타입 변수로, 세부적인 타입이 아직 결정되지 않았지만, 나중에 특정 타입으로 대체될 수 있는 장소를 마련해두는 역할을 함.
- 예: 파이썬의 리스트 제네릭 타입. List[int]는 정수 리스트를 의미, List[str]은 문자열 리스트를 의미. int나 str은 list 타입의 타입 매개변수
- 제네릭 타입을 사용하면, 함수나 클래스 등이 특정 타입의 데이터만을 다루는 것이 아니라, 여러 다른 타입의 데이터를 동일한 방식으로 처리할 수 있게 됨 => 코드의 재사용성을 높여주고, 타입 안전성을 유지하는 데도 도움이 됨