### Docstring in FastAPI
- router안에 parameter로 description을 넣어줘도 되고, router 밑의 함수에 docstring으로 설명을 넣어줘도 swagger에서 확인 가능. 그런데 description과 docstring을 둘 다 넣어줬을 경우에는 description이 먼저 보이는 거 같음.


### filter, filter_by
- filter
    - 일반적으로 SQL 표현식을 인자로 받음
    - 필드 이름과 값을 비교하는 방식으로 작동하며, 더 복잡한 쿼리를 작성하는 데 유용
    - 예) filter(User.name == 'John')
- filter_by
    - 키워드 인자를 사용하여 필터링을 수행
    - 간단한 쿼리를 작성하는 데 유용하며, 필드 이름을 직접 지정할 수 있음
    - 예) filter_by(name='John')

### CRUD 작업
- 라우터에서 DB에 접속(Dependency Injection 사용)
    - 장점
        - 명시적인 의존성: depends(get_db)를 사용함으로써 각 경로 작업이 필요로 하는 의존성을 명확하게 표현
        - 재사용성과 테스트 용이성: get_db 의존성을 사용함으로써 코드의 재사용성이 증가하고, 테스트가 용이해짐. 테스트 시에 다른 데이터베이스 세션을 주입할 수 있음
    - 단점
        - 라우터 레벨의 복잡성: 모든 라우터 함수에서 데이터베이스 세션을 명시적으로 다뤄야함. 이는 라우터의 복잡성을 증가시킬 수 있음.
- 서비스 계층에서 DB에 접속
    - 장점
        - 캡슐화: 데이터베이스 로직을 서비스 계층에 캡슐화함으로써 라우터는 비즈니스 로직과 분리되어 단순해짐
        - 재사용성: 서비스 함수는 다른 서비스나 라우터에서 재사용될 수 있으며, 각기 다른 컨텍스트에서 사용될 수 있음
    - 단점
        - 숨겨진 의존성: 의존성이 서비스 내부에 숨겨져 있어서, 함수가 실제로 어떤 외부 요소에 의존하는지 명확하지 않을 수 있음
        - 테스트 복잡성: 서비스 계층을 테스트할 때, 데이터베이스 세션을 모킹하는 것이 더 복잡해질 수 있음
- 별도의 CRUD.py에서 db에 접속
    - 장점
        - 분리와 집중: 데이터베이스 작업을 완전히 분리하여 집중적으로 관리할 수 있음. 이는 복잡한 쿼리나 여러 테이블과의 작업을 단순화시킬 수 있음
        - 재사용성과 유지 보수성: 특저 데이터 모델에 대한 CRUD 작업을 중화함으로써 코드의 재사용성과 유지 보수성이 향상됨
    - 단점
        - 추가 계층: 애플리케이션에 또 다른 계층이 추가되어, 구조가 더 복잡해질 수 있음
        - 의존성 관리: 서비스 계층과 마찬가지로, CRUD 계층 내에서의 의존성 관리가 중요해짐
- 결론
    - 각 방법에는 장담점이 있음
    - 가장 적합한 방법은 애플리케이션의 복잡성, 팀의 선호도, 유지 보수의 용이성 등 여러 요소를 고려하여 결정되어야 함
    - 일반적으로, 의존성 주입을 사용하는 첫 번째 방법이 FastAPI의 설계 철학과 가장 잘 어울리며, 명시적으로 테스트하기 쉬운 코드를 장려함
    - 하지만, 복잡한 애플리케이션에서는 데이터베이스 작업을 분리하고 캡슐화하는 것이 유리할 수 있음

### 스키마 순서
- 일반적으로 아래 두 가지 기준으로 나열함
    - 사용 빈도수: 가장 많이 사용되는 스키마를 위쪽에 배치해서 코드를 읽는 사람이 보기 쉽도록 하기
    - 의존성: 한 스키마가 다른 스키마를 필드로 참조하는 경우, 참조되는 스키마를 먼저 정의해야 함.

### get_db로 보는 의존성 주입의 이점
- 분리와 추상화
    - 분리: get_db 함수는 데이터베이스 세션을 생성하고 관리하는 로직을 단일 위치에서 처리함. 이는 데이터베이스 연결 관리 코드를 한 곳에 집중시켜 다른 부분에서 재사용할 수 있도록 함
    - 추상화: 라우터나 서비스 계층은 데이터베이스 연결이 어떻게 생성되고 관리되는지 알 필요가 없음. 이들은 단순히 get_db 의존성을 통해 필요한 연결을 받음. 이렇게 하면 구현 세부 사항이 추상화되고, 다양한 컨텍츠트에서 동일한 방식으로 DB연결을 재사용할 수 있음
- 일관성과 유지 보수성
    - 일관성: 모든 라우터와 서비스가 get_db를 사용하면 데이터베이스 세션 관리에 대한 일관된 접근 방식을 유지할 수 있음. 이는 코드베이스 전반에 걸쳐 동일한 패턴을 사용함으로써 익숙해지고 이해하기 쉬운 코드를 만듦.
    - 유지보수성: 데이터베이스 연결 로직을 변경해야 할 경우, get_db 함수만 수정하면 됨. 이는 변경 사항이 프로젝트 전체에 걸쳐 일관되게 적용되도록 하여, 유지보수를 용이하게 함.
- 테스트와 용이성
    - 의존성 대체: 테스트를 작성할 때, 실제 데이터베이스 대신 모의 객체(mock object)나 다른 테스트용 데이터베이스를 사용할 수 있음. get_db를 통해 이러한 대체 의존성을 주입하면, 실제 데이터베이스에 의존하지 않고 코드를 테스트할 수 있음.
    - 분리된 관심사: 데이터베이스 연결 방식을 걱정하지 않고, 비즈니스 로직이 올바르게 작동하는지에 집중하여 테스트를 작성할 수 있음.
- 유연성
    - 환경 적응성: 개발, 테스트, 프로덕션 등 다양한 환경에서 다른 데이터베이스 설정이나 연결 방식을 사용할 수 있음. get_db 함수를 통해 이러한 환경별 설정을 캡슐화하면, 애플리케이션을 다양한 환경에 쉽게 적용할 수 있음.
    
### get_db로 발생할 수 있는 문제점
- FastAPI와 같은 비동기 프레임워크에서 get_db와 같은 제너레이터를 사용하여 데이터베이스 세션을 관리할 때 몇 가지 주의해야 할 문제점들이 있음. 별도의 crud.py에서 get_db 제너레이트럴 사용할 때 발생할 수 있는 문제점들과 해결법은 다음과 같음
- 문제점
    - 비동기 코드와의 호환성: FastAPI는 비동기 코드를 많이 사용함. 그러나 많은 데이터베이스 드라이버와 세션 관리 시스템은 비동기 코드와 자연스럽게 호환되지 않을 수 있음. get_db가 동기 방식으로 작동하면, 비동기 라우터나 서비스 함수에서 문제가 발생할 수 있음
    - 세션의 생명주기 관리: get_db 제너레이터는 요청마다 데이터베이스 세션을 생성하고 종료함. 별도의 CRUD.py에서 이를 잘못 관리하면, 세션이 너무 일찍 닫히거나 열려 있는 상태로 남아 리소스 누수가 발생할 수 있음
    - 예외 처리: 데이터베이스 연결 중 오류가 발생하면 적절하게 처리되어야 함. get_db를 통해 생성된 세션에서 발생하는 예외를 적절히 처리하지 않으면, 애플리케이션의 다른 부분에 영향을 줄 수 있음
- 해결 방법
    - 비동기 데이터베이스 라이브러리 사용: 비동기 프로그래밍을 완전히 지원하는 라이브러리(예: databases, asyncpg)를 사용하여, 데이터베이스 연산을 비동기적으로 처리할 수 있도록 함. 이렇게 하면 애플리케이션의 다른 비동기 코드와 자연스럽게 통합될 수 있음
    - 명확한 세션 관리: 데이터베이스 세션을 사용할 때는 세션의 생명주기를 명확하게 관리해야 함. 특히, CRUD.py에서는 각 함수가 세션을 필요로 할 때 명시적으로 받도록하여, 세션의 시작과 종료를 제어할 수 있게 함. 또한, 예외 발생 시 세션을 안전하게 종료하도록 예외 처리 코드를 작성함.
    - 의존성 주입 사용: CRUD 작업을 별도의 모듈로 분리할 때도 FastAPI의 의존성 주입 시스템을 활용. 이렇게 하면 get_db의 사용이 일관되게 유지되고, 데이터베이스 세션의 생명주기가 적절히 관리됨.
    - 테스트와 로깅: 데이터베이스 연결과 세션 관리에 대한 충분한 테스트와 로깅을 구현하여 문제를 빠르게 발견하고 해결할 수 있도록 함. 이는 잠재적인 문제를 사전에 감지하고 디버깅을 용이하게 함.