### Nginx
- 소프트웨어 웹 서버: HTTP 프로토콜을 이용해 사용자의 웹 브라우저와 통신함. 대표적인 웹 서버 소프트웨어로는 Apache, Nginx, Microsoft IIS 등이 있음. 이 소프트웨어는 사용자로부터 웹 페이지 접근 요청을 받으면, 해당하는 웹 페이지나 파일을 찾아 사용자에게 전송함.
- 장점
    - 정적 파일 처리
        - 성능 향상: Nginx는 정적 파일(HTML, CSS, 이미지 등)을 처리하는 데 최적화되어 있음. FastAPI와 같은 애플리케이션 서버는 주로 동적 콘텐츠를 처리하는 데 사용되므로, Nginx를 프론트에 두어 정적 파일 요청을 처리하게 함으로써 전체적인 서버의 성능을 향상시킬 수 있음.
    - 리버스 프록시
        - 보안 및 익명성 향상: Nginx를 리버스 프록시로 사용하면, 실제 애플리케이션 서버(FastAPI)의 정보를 숨길 수 있음. 이는 외부의 직접적인 접근으로부터 애플리케이션 서버를 보호하는 역할을 함.
        - 부하 분산: 여러 애플리케이션 서버 인스턴스가 있을 때 Nginx는 요청을 여러 서버에 분산시켜 처리할 수 있음. 이를 통해 서버의 부하를 균등하게 분산시키고, 가용성과 확장성을 향상시킬 수 있음.
    - SSL/TLS 처리
        - 암호화된 연결: Nginx는 SSL/TLS 설정을 통해 HTTPS 연결을 구성할 수 있음. 이를 통해 데이터의 안전한 전송을 보장하고, 사용자의 정보를 보호할 수 있음
    - 설정과 관리의 용이성
        - 고급 구성 옵션: Nginx는 다양한 고급 구성 옵션을 제공함. URL 재작성, 캐시 관리, 액세스 제어 등 다양한 기능을 통해 웹 애플리케이션의 성능과 보안을 향상시킬 수 있음.
- Nginx 사용 방법
    - Nginx 설치: EC2 인스턴스에 Nginx를 설치함.
    - 구성 파일 설정: Nginx의 구성 파일(보통 /etc/nginx/nginx.conf 또는 /etc/nginx/sites-available/your_domain에 위치)을 편집하여 리버스 프록시 설정을 추가함. 여기에는 FastAPI 서버가 사용하는 포트로의 프록시 패스 설정이 포함됨.
    - SSL/TLS 설정: 필요한 경우, Let's Encrypt와 같은 서비스를 사용하여 SSL/TLS 인증서를 발급받고, Nginx에 설정하여 HTTPS 연결을 활성화함.
    - Nginx 재시작: 설정을 변경한 후 Nginx를 재시작하여 변경사항을 적용함.
- 이런 방식으로 Nginx를 설정하면, 외부 요청은 먼저 Nginx를 통과하고, Nginx는 해당 요청을 FastAPI 서버로 전달함. 이 과정에서 Nginx는 정적 파일 처리, 보안 강화, 부하 분산 등의 역할을 수행함.

### HTTPS 적용
1. EC2 인스턴스 준비
    - EC2 인스턴스가 실행 중이어야 하며, 웹 서버가 설치되어 있어야 합니다. Apache 또는 Nginx와 같은 웹 서버를 예로 들 수 있음.
    - 보안 그룹 설정에서 80번(HTTP) 포트와 443번(HTTPS) 포트가 열려 있어야 함.
2. 도메인 이름 설정
    - EC2 인스턴스에 대해 도메인 이름이 설정되어 있어야 함. Route 53 또는 다른 DNS 서비스를 사용하여 도메인 이름을 EC2 인스턴스의 IP 주소와 연결함.
3. Certbot 설치
    - Certbot은 Let's Encrypt 인증서를 자동으로 설치하고 갱신해 주는 도구. 운영 체제에 따라 설치 방법이 다를 수 있음.
4. 인증서 발급 및 설치
    - 웹 서버와 통합하여 인증서를 발급받고 자동으로 설치하려면 다음 명령을 사용
5. 자동 갱신 설정
    - Let's Encrypt 인증서는 90일마다 갱신해야 함. Certbot은 자동 갱신을 위한 스크립트를 제공함.
- AWS에서 제공하는 추가 서비스, 예를 들어 AWS Certificate Manager(ACM)를 사용하여 SSL/TLS 인증서를 관리하는 방법도 있음. ACM을 사용하면 AWS 클라우드 내에서 인증서를 쉽게 관리할 수 있지만, 일반적으로 ELB(로드 밸런서) 또는 CloudFront와 같은 다른 AWS 서비스와 함께 사용됨.
- https://chat.openai.com/share/ed5dcc8e-1f4d-4fcb-892d-1cca4175d5af

### 기타 용어
TODO: 이벤트 기반 트래픽, EDA(Event Driven Architecture)
    - 볼 것: https://techblog.woowahan.com/7835/
    - https://www.youtube.com/watch?v=BnS6343GTkY
TODO: 볼 거
    - OAuth 2.0 and OpenID Connect (in plain English)
        - https://www.youtube.com/watch?v=996OiexHze0

### 비동기 방식
- 별도 스레드를 통한 HTTP 방식
- 메시징 시스템을 이용한 방식

### ID 공급업체
- Identity Provider
- 사용자의 신원을 확인하고 인증하는 서비스를 제공하는 업체
- 사용자의 로그인 정보를 관리하고, 애플리케이션에게 사용자 인증 결과를 제공
- ID 공급업체들은 OAuth(Open Authorization) 프로토콜을 사용하여 사용자 인증을 처리함
- 애플리케이션은 ID 공급업체의 인증 서비스를 사용하여 사용자의 신원을 확인하고, 사용자의 동의를 얻어 필요한 정보(예: 이메일 주소, 프로필 정보 등)에 접근할 수 있음

### 리디렉션 URL
- 인증 공급자(예: 구글, 페이스북)가 사용자 인증 후 사용자 브라우저를 다시 클라이언트 애플리케이션으로 리디렉트(redirect)하기 위해 사용하는 웹 주소
    - 리디렉트: 웹 브라우징에서 한 웹 페이지 또는 URL로부터 다른 페이지나 URL로 자동으로 이동하는 것을 의미
- 이 URL은 OAuth 인증 과정의 중요한 부분으로, 보안과 흐름 제어에 중요한 역할을 함
- 역할 
    - 액세스 토큰 전달: OAuth에서 가장 일반적인 사용 사례 중 하나는 인증 공급자가 액세스 토큰(또는 인증 코드)을 클라이언트 애플리케이션에 안전하게 전달하는 것. 이 토큰은 리디렉션 URL의 일부로서 쿼리 파라미터에 추가될 수 있음.
    - 사용자 경험: 사용자가 서드파티 서비스를 통해 로그인하거나 권한을 부여한 후, 리디렉션 URL을 통해 원래의 클라이언트 애플리케이션으로 돌아갈 수 있도록 함. 이는 사용자 경험을 향상시키고, 사용자가 서비스 사용을 계속할 수 있게 함.
    - 보안: 리디렉션 URL은 클라이언트 애플리케이션을 등록할 때 인증 공급자에 의해 사전에 설정되며, 인증 과정 중에만 사용됨. 이는 인증 공급자가 액세스 토큰을 오직 등록된, 신뢰할 수 있는 리디렉션 URL로만 전달하게 하여 보안을 강화함.
- 리디렉션 URL 설정
    - 클라이언트 애플리케이션을 인증 공급자에 등록할 때, 하나 이상의 리디렉션 URL을 제공해야 함.
    - 인증 과정을 시작할 때 redirect_uri 파라미터에 이 URL을 명시하여 인증 공급자에 전달함.
    - 사용자 인증이 완료된 후, 인증 공급자는 사용자의 웹 브라우저를 이 URL로 리디렉트하며, 필요한 정보(예: 액세스 토큰, 인증 코드)를 URL 파라미터에 추가함.
    - 리디렉션 URL은 OAuth 인증 프로세스의 안전과 효율성을 보장하기 위해 필수적이며, 올바르게 설정하고 관리하는 것이 중요함.

### OAuth 리디렉션 URL
- OAuth 인증 과정에서 사용되는 중요한 개념
- 역할
    1. 사용자 인증 완료 후 리디렉션
        - 사용자가 ID 공급업체의 로그인 페이지에서 인증을 완료하면, ID 공급업체는 사용자를 OAuth 리디렉션 URL로 리디렉션시킴.
        - 이 URL은 애플리케이션에서 지정한 URL로, 사용자 인증 결과를 전달받을 수 있는 엔드포인트.
    2. 인증 코드 전달
        - ID 공급업체는 사용자 인증이 성공적으로 완료되면, OAuth 리디렉션 URL에 인증 코드(Authorization Code)를 포함하여 리디렉션함.
        - 인증 코드는 일회성 코드로, 애플리케이션이 액세스 토큰(Access Token)을 얻기 위해 사용됨.
    3. 애플리케이션에서 인증 코드 수신
        - 애플리케이션은 OAuth 리디렉션 URL에서 인증 코드를 받아, ID 공급업체의 토큰 엔드포인트에 액세스 토큰을 요청함.
        - 액세스 토큰을 받으면, 애플리케이션은 사용자의 정보에 접근할 수 있는 권한을 얻게 됨.
- 사용 시 주의할 점
    - URL은 애플리케이션에서 제어할 수 있는 유효한 엔드포인트여야 함.
    - URL은 ID 공급업체에 등록되어야 하며, 애플리케이션과 ID 공급업체 간에 일치해야 함.
    - URL은 보안 조치가 적용된 HTTPS 프로토콜을 사용해야 함.

### /auth/callback
- `/auth/callback` API는 주로 인증 과정에서 사용되는 엔드포인트. 사용자가 외부 인증 제공자(예: Google, Facebook, Twitter 등)를 통해 로그인하려 할 때, 이 과정을 처리하는 데 사용됨. 여기서 "callback"이라는 용어는 외부 인증 제공자가 사용자의 인증 과정을 완료한 후 사용자의 정보와 함께 웹 애플리케이션으로 다시 "되돌아가는" 방식을 의미. 
- 주요 역할
    - 인증 과정 완료 후 리디렉션 처리: 사용자가 외부 서비스를 통해 인증을 완료하면, 해당 서비스는 사용자를 원래의 애플리케이션으로 리디렉션함. 이 때 `/auth/callback` 엔드포인트가 호출되며, 인증 제공자로부터 전달받은 정보(예: 액세스 토큰, 사용자 프로필 정보 등)를 처리함.
    - 사용자 정보 검증 및 처리: `/auth/callback` 엔드포인트는 인증 제공자로부터 전달받은 정보를 검증하고, 필요한 경우 추가적인 사용자 정보를 요청함. 검증 과정은 보안을 위해 매우 중요하며, 애플리케이션의 사용자 데이터베이스에 정보를 저장하거나 업데이트하는 등의 작업을 포함할 수 있음.
    - 세션 생성 및 쿠키 설정: 사용자의 인증 정보가 검증되면, 웹 애플리케이션은 사용자에 대한 세션을 생성하고 쿠키를 설정하여, 사용자가 로그인 상태를 유지할 수 있도록 함. 이는 사용자가 애플리케이션을 탐색할 때 로그인 상태를 유지하는 데 필수적.
    - 사용자 경험 개선: `/auth/callback` 엔드포인트는 사용자가 성공적으로 인증되었을 때 적절한 페이지로 리디렉션하는 역할도 함. 예를 들어, 사용자가 로그인 후 보게 될 홈페이지나 사용자 대시보드로의 리디렉션 등이 이에 해당함.
- 안전 주의사항
    - SSL/TLS를 사용하여 데이터를 안전하게 전송하도록 해야 함.
    - 클라이언트 측과 서버 측 모두에서 입력 값을 해야 함.
    - ID 토큰의 유효성을 검사할 때는 발급자(issuer)와 대상(audience)을 항상 검증해야 함.

### OAuth 구현 방법
- 3-legged OAuth
    - 이 방법은 가장 일반적으로 사용되며, 사용자, 클라이언트 애플리케이션, 그리고 서비스 제공자 사이의 상호 작용을 필요로 함. 이 과정에서 사용자는 클라이언트 애플리케이션이 자신의 데이터에 접근하는 것을 명시적으로 승인함. 예를 들어, 소셜 미디어 플랫폼에 게시하기 위해 서드파티 애플리케이션에 접근 권한을 부여할 때 사용됨.
    1. 사용자 승인 요청: 클라이언트 애플리케이션은 사용자를 서비스 제공자의 승인 페이지로 리다이렉트합함.
    2. 사용자 승인: 사용자가 승인하면, 서비스 제공자는 클라이언트에게 승인 코드를 발급함.
    3. 액세스 토큰 요청: 클라이언트 애플리케이션은 승인 코드를 사용하여 서비스 제공자에게 액세스 토큰을 요청함.
    4. 액세스 토큰 수령 및 리소스 요청: 클라이언트 애플리케이션이 액세스 토큰을 받으면, 이를 사용하여 사용자의 데이터에 접근할 수 있음.
- 2-legged OAuth
    - 이 방법은 더 단순하며, 주로 두 시스템 간의 신뢰 관계가 필요할 때 사용됨. 예를 들어, 기업 내부 애플리케이션 간의 상호 작용이나, 애플리케이션과 서비스 제공자 간의 서버-투-서버 통신에 적합함. 이 경우, 사용자의 명시적 승인 없이도 액세스 토큰이 발급됨.
    1. 클라이언트 인증: 클라이언트는 자신을 인증하기 위해 서비스 제공자에게 클라이언트 ID와 시크릿을 제공함.
    2. 액세스 토큰 발급: 인증이 성공하면, 서비스 제공자는 클라이언트에게 액세스 토큰을 직접 발급함.
    3. 리소스 요청: 클라이언트는 발급받은 액세스 토큰을 사용하여 리소스에 접근함.
- 두 방법 사이의 주요 차이점은 사용자의 명시적 승인이 필요한지 여부와 애플리케이션의 유형. 3-legged OAuth는 보다 복잡한 인증 과정을 거치지만, 사용자 데이터에 대한 보다 세밀한 제어를 가능하게 함. 반면, 2-legged OAuth는 상호 신뢰할 수 있는 시스템 간의 간소화된 인증을 제공함.

### OAuth 2.0 프로토콜에서 사용되는 인증 흐름
- 3-legged OAuth의 두 가지 구현 예시
- Authorization Code Grant
    - 보안이 중요한 애플리케이션에 권장되는 방식
    - 이 방식은 클라이언트 애플리케이션이 서버 측에서 실행되는 경우에 적합하며, 애플리케이션 서버가 사용자의 인증 정보를 안전하게 보관할 수 있는 환경에서 사용됨.
    - 액세스 토큰을 안전하게 교환할 수 있는 추가 단계를 제공함으로써 높은 보안성을 보장합니다.
    1. 사용자 인증: 사용자가 서비스 제공자의 로그인 페이지를 통해 인증함.
    2. 승인 코드 발급: 인증 후, 서비스 제공자는 클라이언트 애플리케이션에 대한 승인 코드를 발급함.
    3. 액세스 토큰 요청: 클라이언트 애플리케이션은 승인 코드를 사용하여 서비스 제공자에게 액세스 토큰을 요청함. 이때 클라이언트의 인증 정보를 함께 제공함.
    4. 액세스 토큰 발급: 서비스 제공자는 클라이언트의 인증 정보와 승인 코드를 검증한 후, 액세스 토큰을 발급함.
- Implicit Grant
    - 주로 자바스크립트와 같이 클라이언트 사이드에서 실행되는 애플리케이션을 위해 설계됨.
    - 이 방식은 클라이언트 애플리케이션이 서버 측 코드 없이 직접 액세스 토큰을 받아야 하는 경우에 사용됨.
    1. 사용자 인증: 사용자는 서비스 제공자를 통해 로그인함.
    2. 액세스 토큰 발급: 사용자 인증 후, 서비스 제공자는 승인 코드를 발급하는 대신에 바로 액세스 토큰을 클라이언트 애플리케이션으로 리다이렉트함.
    - Implicit Grant 방식은 Authorization Code Grant보다 단순하며, 서버 사이드 로직이 필요 없기 때문에 클라이언트 사이드 애플리케이션에서 직접 사용하기 쉬움. 
    - 그러나 이 방식은 액세스 토큰이 클라이언트 사이드를 통해 직접 전달되기 때문에 보안상의 위험이 더 높음.
    - 이러한 이유로, OAuth 2.1에서는 Implicit Grant의 사용을 권장하지 않음.

### Server-side, Client-side OAuth
- Server-side OAuth
    - 적용 환경: 서버 사이드 OAuth는 백엔드 서버에서 실행되는 애플리케이션에 적합함. 이 방식은 애플리케이션의 서버가 사용자의 인증 정보를 처리하고, 리소스 서버(예: 소셜 미디어 플랫폼)와 안전하게 통신함.
    - 인증 흐름: 주로 Authorization Code Grant 흐름을 사용함. 이 흐름은 사용자가 서비스 제공자를 통해 로그인한 후, 서버 측 애플리케이션에 "인증 코드"를 제공하고, 이를 사용하여 액세스 토큰을 안전하게 교환할 수 있도록 함.
    - 보안: 서버 사이드 OAuth는 애플리케이션 서버가 클라이언트 비밀(client secret)을 안전하게 보관할 수 있기 때문에 높은 보안 수준을 제공함. 이 비밀 정보는 액세스 토큰을 요청할 때 사용됨.
- Client-side OAuth
    - 적용 환경: 클라이언트 사이드 OAuth는 주로 웹 브라우저나 모바일 애플리케이션과 같이 사용자의 디바이스에서 직접 실행되는 클라이언트 애플리케이션에 사용됨. 이 방식은 백엔드 서버와의 통신 없이 직접 리소스 서버에 접근함.
    - 인증 흐름: Implicit Grant 흐름이나, 최근 더 권장되는 PKCE(Proof Key for Code Exchange)를 활용한 Authorization Code Grant 흐름이 사용됨. 이들 흐름은 클라이언트 애플리케이션에서 직접 액세스 토큰을 얻을 수 있도록 설계됨.
    - 보안: 클라이언트 사이드 OAuth는 클라이언트 비밀을 안전하게 보관할 수 없기 때문에 보안에 더 많은 주의가 필요함. PKCE를 사용하는 것이 보안을 강화하는 현대적인 접근 방식.

### PKCE
- PKCE(Proof Key for Code Exchange)는 OAuth 2.0의 Authorization Code Grant 방식에서 보안을 강화하기 위해 사용되는 기법. 
- 주로 모바일 앱이나 자바스크립트 기반의 싱글 페이지 애플리케이션(SPA)에서 사용되며, 인증 과정에서 발생할 수 있는 권한 코드 절도(Authorization Code Interception) 공격을 방지하는 데 도움이 됨.
- 동작 방식
    1. 클라이언트는 코드 챌린지(Code Challenge)와 코드 검증자(Code Verifier)를 생성함.
        - 코드 검증자는 클라이언트에서 생성한 임의의 문자열..
        - 코드 챌린지는 코드 검증자를 변환한 값 (SHA256 해시 함수를 사용하는 것이 일반적)
    2. 클라이언트는 인증 요청 시 생성한 코드 챌린지를 함께 전송함.
    3. 인증 서버는 받은 코드 챌린지를 저장해둠.
    4. 사용자가 인증을 완료하면 인증 서버는 Authorization Code를 클라이언트에게 전달함.
    5. 클라이언트는 Authorization Code와 함께 코드 검증자를 인증 서버로 전송하여 Access Token을 요청함.
    6. 인증 서버는 받은 코드 검증자를 이전에 저장해둔 코드 챌린지와 비교하여 검증함.
        - 코드 검증자를 변환한 값과 코드 챌린지가 일치하면 유효한 요청으로 판단하고 Access Token을 발급함.
        - 일치하지 않으면 잘못된 요청으로 판단하고 Access Token 발급을 거부함.
- 이러한 과정을 통해 PKCE는 중간자 공격(Man-in-the-Middle Attack)이나 권한 코드 절도 공격으로부터 OAuth 인증 과정을 보호할 수 있음. 
- PKCE를 사용하면 권한 코드가 유출되더라도 공격자가 코드 검증자를 모르기 때문에 Access Token을 발급받을 수 없게 됨.
- PKCE는 OAuth 2.0 보안 최적화를 위해 강력히 권장되는 기법이며, 최신 OAuth 라이브러리와 프레임워크에서는 PKCE를 기본적으로 지원하고 있음.

### Client Secret
- Client Secret은 OAuth에서 클라이언트 애플리케이션의 인증에 사용되는 비밀 코드
- 이는 OAuth를 사용하여 서비스 제공자와 통신할 때 클라이언트 애플리케이션이 자신을 식별하고 인증하기 위해 필요한 문자열. 클라이언트 애플리케이션을 서비스 제공자에 등록할 때 생성되며, 애플리케이션 개발자에게 제공됨.
- Client Secret의 역할
    - 인증: Client Secret은 애플리케이션의 서버 측이 서비스 제공자와 통신할 때 자신을 식별하고 인증하는 데 사용됨 예를 들어, 액세스 토큰을 요청할 때 클라이언트 ID와 함께 제공되어, 해당 애플리케이션이 등록된 클라이언트임을 증명함.
    - 보안: 비밀번호와 유사하게, Client Secret은 애플리케이션과 서비스 제공자 사이의 통신을 보호하기 위한 중요한 보안 요소. 악의적인 사용자가 이 비밀 코드를 알게 되면, 해당 사용자는 애플리케이션을 사칭할 수 있으므로, 이를 안전하게 보관하고 유출되지 않도록 관리해야 함.
- Client Secret의 관리
    - 보안 저장: Client Secret은 서버 측에서 안전하게 저장되어야 하며, 클라이언트 사이드 코드(예: 웹 페이지의 JavaScript)나 저장소에 포함시켜서는 안 됨. 서버 환경에서만 접근 가능하도록 해야 함.
    - 주의사항: 만약 Client Secret이 노출되면, 해당 애플리케이션의 보안이 크게 위협받게 됨. 이 경우, 서비스 제공자에게 즉시 알리고, 새로운 Client Secret으로 교체해야 함.
- 사용 시나리오
    - 서버 사이드 애플리케이션: Client Secret은 서버 사이드 애플리케이션에서 OAuth 인증을 사용할 때 주로 필요함. 예를 들어, Authorization Code Grant 흐름에서 액세스 토큰을 안전하게 요청하는 데 사용됨.
    - 클라이언트 사이드 애플리케이션: 클라이언트 사이드 애플리케이션(예: SPA, 모바일 앱)에서는 Client Secret을 안전하게 저장할 수 없으므로, 대신 PKCE(Proof Key for Code Exchange)와 같은 보안 메커니즘을 사용하여 인증 과정의 보안을 강화함.

