### TODO
- 이벤트 기반 트래픽, EDA(Event Driven Architecture)
    - 볼 것: https://techblog.woowahan.com/7835/
    - https://www.youtube.com/watch?v=BnS6343GTkY

### 응답 코드
- 200: GET, PUT
- 201: POST
- 204: DELETE
- https://juna-dev.tistory.com/16

### Dependency
- 코드에서 두 모듈 간의 연결
- OOP에서는 두 클래스 간의 관계라고도 말함
- 일반적으로 둘 중 하나가 다른 하나를 어떤 용도를 위해 사용함
- Dependency가 위험한 이유
    - 하나의 모듈이 바뀌면 의존한 다른 모듈가지 변경이 이루어지기 때문
    - 테스트 가능한 어플을 만들 때 의존성이 있으면 유닛테스트 작성이 어려움 -> 유닛테스트의 목적 자체가 다른 모듈로부터 독립적으로 테스트하는 것을 요구하기 때문
- https://tony-programming.tistory.com/entry/Dependency-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%9D%B4%EB%9E%80

### Dependency Injection
- Dependency가 위험한 이유를 해결하기 위해 사용
- 디자인 패턴으로 모듈이나 컴포넌트의 의존성을 런타임에 주입할 수 있도록 함
- 궁극적인 목적: 관심사 분리
- DIP(Dependency Injection Principle)
    - SOLID 원칙 중 하나
    - 상위 모듈을 하위 모듈에 의존해서는 안된다. 둘다 추상화에 의존해야 한다.
    - 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.
- FastAPI에서는 Depends, django에서는 dictionary를 이용하여 DI를 함
- https://velog.io/@heyoni/Dependency-Injection

### Nginx
- 소프트웨어 웹 서버: HTTP 프로토콜을 이용해 사용자의 웹 브라우저와 통신함. 대표적인 웹 서버 소프트웨어로는 Apache, Nginx, Microsoft IIS 등이 있음. 이 소프트웨어는 사용자로부터 웹 페이지 접근 요청을 받으면, 해당하는 웹 페이지나 파일을 찾아 사용자에게 전송함.
- 장점
    - 정적 파일 처리
        - 성능 향상: Nginx는 정적 파일(HTML, CSS, 이미지 등)을 처리하는 데 최적화되어 있음. FastAPI와 같은 애플리케이션 서버는 주로 동적 콘텐츠를 처리하는 데 사용되므로, Nginx를 프론트에 두어 정적 파일 요청을 처리하게 함으로써 전체적인 서버의 성능을 향상시킬 수 있음.
    - 리버스 프록시
        - 보안 및 익명성 향상: Nginx를 리버스 프록시로 사용하면, 실제 애플리케이션 서버(FastAPI)의 정보를 숨길 수 있음. 이는 외부의 직접적인 접근으로부터 애플리케이션 서버를 보호하는 역할을 함.
        - 부하 분산: 여러 애플리케이션 서버 인스턴스가 있을 때 Nginx는 요청을 여러 서버에 분산시켜 처리할 수 있음. 이를 통해 서버의 부하를 균등하게 분산시키고, 가용성과 확장성을 향상시킬 수 있음.
    - SSL/TLS 처리
        - 암호화된 연결: Nginx는 SSL/TLS 설정을 통해 HTTPS 연결을 구성할 수 있음. 이를 통해 데이터의 안전한 전송을 보장하고, 사용자의 정보를 보호할 수 있음
    - 설정과 관리의 용이성
        - 고급 구성 옵션: Nginx는 다양한 고급 구성 옵션을 제공함. URL 재작성, 캐시 관리, 액세스 제어 등 다양한 기능을 통해 웹 애플리케이션의 성능과 보안을 향상시킬 수 있음.
- Nginx 사용 방법
    - Nginx 설치: EC2 인스턴스에 Nginx를 설치함.
    - 구성 파일 설정: Nginx의 구성 파일(보통 /etc/nginx/nginx.conf 또는 /etc/nginx/sites-available/your_domain에 위치)을 편집하여 리버스 프록시 설정을 추가함. 여기에는 FastAPI 서버가 사용하는 포트로의 프록시 패스 설정이 포함됨.
    - SSL/TLS 설정: 필요한 경우, Let's Encrypt와 같은 서비스를 사용하여 SSL/TLS 인증서를 발급받고, Nginx에 설정하여 HTTPS 연결을 활성화함.
    - Nginx 재시작: 설정을 변경한 후 Nginx를 재시작하여 변경사항을 적용함.
- 이런 방식으로 Nginx를 설정하면, 외부 요청은 먼저 Nginx를 통과하고, Nginx는 해당 요청을 FastAPI 서버로 전달함. 이 과정에서 Nginx는 정적 파일 처리, 보안 강화, 부하 분산 등의 역할을 수행함.

### HTTPS 적용
1. EC2 인스턴스 준비
    - EC2 인스턴스가 실행 중이어야 하며, 웹 서버가 설치되어 있어야 합니다. Apache 또는 Nginx와 같은 웹 서버를 예로 들 수 있음.
    - 보안 그룹 설정에서 80번(HTTP) 포트와 443번(HTTPS) 포트가 열려 있어야 함.
2. 도메인 이름 설정
    - EC2 인스턴스에 대해 도메인 이름이 설정되어 있어야 함. Route 53 또는 다른 DNS 서비스를 사용하여 도메인 이름을 EC2 인스턴스의 IP 주소와 연결함.
3. Certbot 설치
    - Certbot은 Let's Encrypt 인증서를 자동으로 설치하고 갱신해 주는 도구. 운영 체제에 따라 설치 방법이 다를 수 있음.
4. 인증서 발급 및 설치
    - 웹 서버와 통합하여 인증서를 발급받고 자동으로 설치하려면 다음 명령을 사용
5. 자동 갱신 설정
    - Let's Encrypt 인증서는 90일마다 갱신해야 함. Certbot은 자동 갱신을 위한 스크립트를 제공함.
- AWS에서 제공하는 추가 서비스, 예를 들어 AWS Certificate Manager(ACM)를 사용하여 SSL/TLS 인증서를 관리하는 방법도 있음. ACM을 사용하면 AWS 클라우드 내에서 인증서를 쉽게 관리할 수 있지만, 일반적으로 ELB(로드 밸런서) 또는 CloudFront와 같은 다른 AWS 서비스와 함께 사용됨.
- https://chat.openai.com/share/ed5dcc8e-1f4d-4fcb-892d-1cca4175d5af

### 데이터 모킹
- 테스트 또는 개발 과정에서 실제 운영 환경이나 외부 시스템 대신 사용할 수 있는 가짜 데이터나 객체를 생성하는 기술. 실제 데이터나 시스템의 복잡성, 불안정성, 비용 등의 문제를 피하면서 소프트웨어를 테스트하거나 개발할 수 있게 해줌. 모킹을 특히 단위 테스트에서 중요한 역할을 하며, 종속성을 가진 코드를 격리시켜 테스트의 정확성과 신뢰성을 높임.
- 주요 용도
    - 테스트 격리: 테스트를 수행할 때 외부 시스템, 네트워크 호출, 데이터베이스와 같은 의존성으로부터 코드를 격리함. 이는 테스트가 의존성의 상태나 행동에 영향을 받지 않도록 하여, 더 일관되고 예측 가능한 결과를 얻을 수 있게 함.
    - 환경 제어: 실제 환경을 정확히 제어하기 어려울 때, 모킹을 사용하면 테스트 환경을 완벽하게 제어할 수 있음. 예를 들어, 특정 데이터를 반환하거나 특정 오류를 유발하는 시스템의 행동을 모방할 수 있음.
    - 비용 절감 및 성능 향상: 실제 데이터베이스나 외부 API를 사용하는 대신 모킹된 객체를 사용하면 네트워크 지연, 비용, 한정된 자원 등의 문제를 피할 수 있음. 이는 테스트 속도를 높이고 비용을 절감할 수 있게 함.
    - 개발 편의성: 아직 개발 중이거나 접근할 수 없는 외부 시스템과의 통합을 위해, 개발자는 모킹을 사용하여 가짜 응답이나 데이터를 생성할 수 있음. 이를 통해 개발 과정을 계속 진행할 수 있음.
- 데이터 모킹을 위한 일반적인 방법
    - 가짜 객체(Fake Objects): 실제 객체의 간단한 버전을 구현하여 실제 동작을 모방함. 이는 간단한 시나리오나 테스트에서 유용함.
    - 스탭(Stubs): 특정 메서드나 함수의 반환 값을 하드코딩하여, 테스트 중에 특정 값을 반환하도록 설정함.
    - 모크(Mock Objects): 실제 객체를 대체하는 객체로, 호출된 메서드, 전달된 파라미터, 반환 값 등을 기록함. 이를 통해 테스트 중에 객체의 사용 방법을 검증할 수 있음.
    - 스파이(Spies): 실제 객체의 행동을 모니터링하면서, 호출된 메서드나 전달된 파라미터 등을 기록함. 스파이는 실제 객체를 감싸서 그 행동을 추적함.
- 데이터 모킹은 소프트웨어 개발과 테스트의 필수적인 부분이며, 특히 복잡하고 상호 연결된 시스템을 다룰 때 그 중요성이 더욱 커짐. 올바르게 사용될 때, 모킹은 테스트의 신뢰성을 높이고 개발 과정을 더 원활하게 만들 수 있음.

#### 백엔드 개발자가 운영체제의 이해를 필요로 하는 이유
- 성능 최적화: 운영체제의 작동 원리를 이해하면 시스템의 성능을 최적화하는 데 도움이 됨.
    - 예) 프로세스와 스레드의 관리, 메모리 관리, I/O 처리 등에 대한 이해로 성능 향상
- 리소스 관리: 백엔드 개발은 대부분 서버에서 실행되며, 서버에서는 자원을 효율적으로 사용하는 것이 중요. 운영체제를 이해하면 메모리, CPU, 디스크 등의 리소스를 어떻게 관리하는지 알 수 있음
- 동시성 및 병렬 처리: 동시에 여러 요청을 처리하거나, 복잡한 작업을 여러 부분으로 나누어 병렬로 처리하는 것은 백엔드 개발에서 중요한 부분. 운영체제는 이런 동시성과 병렬 처리를 어떻게 관리하는지에 대한 이해를 제공함
- 보안: 운영체제는 시스템의 보안을 유지하는 데 중요한 역할을 함. 사용자 권한 관리, 메모리 보호, 네트워크 보안 등에 대한 이해는 시스템의 보안을 높이는 데 도움이 됨.

### 비동기 방식
- 별도 스레드를 통한 HTTP 방식
- 메시징 시스템을 이용한 방식

### 스레드
- 프로세스 내에서 실행되는 흐름의 단위
- 한 프로세스 내에서 여러 개의 스레드를 생성하여 병렬 처리를 할 수 있음. 이를 통해 여러 작업을 동시에 처리하거나, I/O 작업이 진행되는 동안 다른 작업을 처리하는 등의 효율적인 작업이 가능함
- 스레드는 각각의 스택을 가지지만, 코드 섹션(code), 데이터 섹션(data), 힙(heap) 등은 공유. 따라서 스레드끼리 데이터를 공유하기 쉽지만, 이로 인해 동기화 문제가 발생할 수 있음
- 예) 두 스레드가 동시에 같은 데이터를 변경하려고 하는 경우, 데이터의 무결성이 깨질 수 있음
- 이런 문제를 해결하기 위해 뮤텍스(mutex), 세마포어(semaphore), 모니터(Monitor) 등의 동기화 기법을 사용함
- 스레드는 멀티코어 또는 멀티프로세서 환경에서 특히 유용하게 사용됨. 각 스레드를 다른 프로세서에서 독립적으로 실행시킴으로써, 프로그램의 실행 속도를 향상시킬 수 있음. 이를 멀티스레딩이라고 함.

### 프로세스
- 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
- 운영체제에서는 프로세스를 각각 독립된 실행 환경으로 관리하며, 각 프로세스는 자신만의 메모리 공간과 자원을 할당받아 사용함
- 스레드는 이 프로세스 내에서 실행되는 하나의 실행 흐름. 한 프로세스 내에서 여러 스레드를 생성하면, 이들 스레드는 프로세스의 메모리 공간과 자원을 공유하면서 병렬적으로 실행될 수 있음
- 프로세스와 스레드는 모두 실행 흐름의 단위
- 프로레스와 스레드의 사용 방식과 특성에 따른 차이
    - 메모리 공간: 프로세스는 각각 독립된 메모리 공간을 가지지만, 스레드는 같은 프로세스 내에서 메모리 공간을 공유함. 이로 인해 스레드간의 통신이 더 간편하지만, 동기화 문제를 주의해야 함
    - 생성 및 관리 비용: 프로세스를 생성하고 관리하는 비용은 스레드에 비해 높음. 따라서 적은 자원으로 동시성을 구현하려면 스레드를 사용하는 것이 효율적
    - 통신 방식: 프로세스 간 통식은 IPC(Inter-Process Communication) 기법을 통해 이루어지며, 복잡한 과정을 거침. 반면 스레드 간 통신은 같은 메모리 공간을 공유하기 때문에 더 간단하고 빠름.
    - 영향 범위: 프로세스 내에서 오류가 발생하면 해당 프로세스만 영향을 받지만, 스레드 내에서 오류가 발생하면 같은 프로세스 내의 다른 스레드도 영향을 받을 수 있음

### 동기화 문제
- 멀티스레딩 환경에서 여러 스레드가 공유 자원에 동시에 접근하려 할 때 발생하는 문제. 
- 대표적인 문제들
    - 경쟁 조건(Rade Condition): 두 개 이상의 스레드가 동시에 공유 데이터에 접근하고, 그 결과가 스레드의 실행 순서에 따라 달라지는 것.
        - 예) 한 스레드가 데이터를 읽어와서 수정하는 도중 다른 스레드가 그 데이터를 변경하면, 첫 번째 스레드는 잘못된 정보를 바탕으로 계산을 하게 됨
    - 교착 상태(Deadlock): 두 개 이상의 스레드가 서로 상대방이 가지고 있는 리소스를 기다리면서 진행을 멈추는 상태.
        - 예) 스레드 A가 락 X를 가지고 잇고 락 Y를 얻기를 기다리는 동안, 스레드 B는 락 Y를 가지고 있고 락 X를 얻기를 기다린다면, 두 스레드는 서로가 가진 락을 놓을 때까지 영원히 기다리게 됨
    - 기아 상태(Starvaion): 특정 스레드가 필요한 리소스를 무한히 얻지 못하고 계속 기다리는 상황. 이는 스케줄링 정책, 리소르 할당 정책 등에 따라 발생할 수 있음

### 락을 획득한다
- 멀티스레딩 환경에서 사용되는 용어
- 여러 스레드가 동시에 공유 자원에 접근하는 것을 방지하기 위한 기법 중 하나
- 락은 상호 배제(Mutex)를 구현하는 코드. 한 번에 하나의 스레드만 특정 코드를 실행하도록 하는 역할을 함. 이를 통해 여러 스레드가 동시에 동일한 리소스에 접근하여 발생할 수 있는 데이터 경쟁 조건을 방지할 수 있음
- 데이터 일관성을 유지하는 데 중요한 역할을 함
- 락을 획득하는 과정
    - 스레드가 공유 자원에 접근하려고 할 때, 락을 획득하려고 시도함
    - 락이 이미 다른 스레드에 의해 획득되엇다면, 그 스레드는 락이 해제될 때까지 기다려야 함. 이를 블로킹(blocking)이라고 함
    - 락이 획득 가능하다면, 그 스레드는 락을 획득하고 공유 자원에 접근하여 작업을 수행함
    - 작업이 끝나면, 스레드는 락을 해제(release)함. 이로 인해 다른 스레드들이 락을 획득하고 공유 자원에 접근할 수 있게 함.
