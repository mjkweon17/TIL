### UNIQUE(`auth_type`, `auth_id`)
- UNIQUE(auth_type, auth_id) 구문: auth_type과 auth_id의 조합이 전체 테이블에서 고유해야 함을 의미

### UNIQUE 제약 조건의 위치
```SQL
CREATE TABLE `Page` (
	`page_id`	INT AUTO_INCREMENT	NOT NULL,
	`english_title`	VARCHAR(255)	NOT NULL,
	`url`	VARCHAR(2083)	UNIQUE  NOT NULL,   //필드 정의와 함께 명시
	`summarization`	TEXT	NOT NULL,
	PRIMARY KEY (`page_id`),
	UNIQUE (`url`)  //테이블 정의의 마지막
);
```
- 두 가지 방식 모두 유효하지만, 각각의 방식이 가지는 의미와 관리의 용이성 측면에서 차이가 있음
- `UNIQUE (`url`)`를 테이블 정의의 마지막에 위치시키는 방식
   - 이 방식은 테이블의 다른 정의(예: 필드 정의, 기본 키 설정 등)를 마친 후, 테이블 수준에서 제약 조건을 추가하는 형태
   - 여러 필드에 걸쳐 `UNIQUE` 제약 조건을 설정할 경우 유용. 예를 들어, `url`과 `english_title`을 함께 고유하게 유지해야 한다면, `UNIQUE (url, english_title)`과 같이 설정할 수 있음.
   - 테이블 수준에서 제약 조건을 정의함으로써, 테이블의 다른 구성 요소와 분리하여 제약 조건을 관리할 수 있습니다.
- `url VARCHAR(2083) UNIQUE NOT NULL`과 같이 필드 정의와 함께 `UNIQUE`를 명시하는 방식
   - 이 방식은 특정 필드에 대해 바로 `UNIQUE` 제약 조건을 적용하는 형태.
   - 필드가 고유해야 한다는 제약을 명확하게 하며, 필드 정의를 읽는 순간 그 필드의 중요성을 이해할 수 있게 함.
   - 단일 필드에 대한 제약 조건을 적용할 때 간결하고 직관적.
- 결론
    - `url` 필드만 고유값을 유지해야 한다면, 필드 정의와 함께 `UNIQUE` 제약 조건을 명시하는 것이 더 명확하고 직관적일 수 있음. 이 방식은 필드 레벨에서 제약 조건을 바로 확인할 수 있으며, 테이블의 다른 구성 요소와 분리하여 고려하지 않아도 됨. 반면, 여러 필드에 걸쳐 복합적인 고유 제약 조건이 필요한 경우에는 테이블 정의의 마지막 부분에 `UNIQUE` 제약 조건을 추가하는 것이 적합함.

### 인덱스
- INDEX(auth_type, auth_id) 구문이 있는 경우와 없는 경우의 차이: 데이터베이스에서 이 필드들에 대한 검색과 조인 작업의 효율성에 있음. 인덱스는 데이터베이스에서 특정 데이터를 더 빠르게 찾을 수 있도록 돕는 데이터 구조. auth_type과 auth_id에 대한 인덱스를 생성함으로써, 이 두 필드를 이용하는 쿼리들이 더 빠르게 실행될 수 있음. 
- 인덱스가 있는 경우
    - 검색 성능 향상: auth_type과 auth_id를 조건으로 사용하는 쿼리는 인덱스 덕분에 해당 데이터를 더 빠르게 찾을 수 있음. 인덱스는 특정 값이 저장된 위치를 가리키므로, 데이터베이스 엔진은 전체 테이블을 순차적으로 검색하지 않고, 인덱스를 통해 필요한 레코드를 훨씬 빠르게 찾을 수 있음.
    - 조인 작업의 최적화: 다른 테이블과 조인할 때 auth_type과 auth_id를 사용하는 경우, 인덱스는 이러한 조인 작업을 훨씬 효율적으로 만들 수 있음. 인덱스가 있으면 데이터베이스는 조인에 필요한 특정 레코드를 빠르게 찾아 성능을 개선할 수 있음.
- 인덱스가 없는 경우
    - 검색 성능 저하: 인덱스가 없으면 데이터베이스는 auth_type과 auth_id를 조건으로 하는 쿼리를 처리할 때 전체 테이블을 순차적으로 검색해야 함. 이는 테이블의 크기가 클수록 성능 저하를 유발하며, 특히 대량의 데이터가 있는 경우 검색 시간이 상당히 늘어날 수 있음.
    - 조인 작업의 비효율: 인덱스가 없는 경우, 조인 작업도 더 많은 시간을 소모하게 됩니다. 데이터베이스는 조인을 위해 참조되는 각 레코드를 찾기 위해 테이블 전체를 검색해야 하므로, 조인 작업이 훨씬 느려질 수 있음.
- 인덱스 단점: 추가적인 저장 공간을 사용하고, 데이터를 삽입, 수정, 삭제할 때 인덱스를 갱신해야 하므로, 이러한 작업의 성능에는 약간의 영향을 줄 수 있음. 따라서, 인덱스를 사용할 때는 검색 성능 향상과 유지 관리 비용 사이의 균형을 고려해야 함.

### UNIQUE 제약조건도 인덱스의 일종
```SQL
CREATE TABLE `Page` (
	`page_id`	INT AUTO_INCREMENT	NOT NULL,
	`english_title`	VARCHAR(255)	NOT NULL,
	`url`	VARCHAR(2083)	UNIQUE  NOT NULL,   //필드 정의와 함께 명시
	`summarization`	TEXT	NOT NULL,
	PRIMARY KEY (`page_id`),
	UNIQUE (`url`)  //테이블 정의의 마지막
);
```
- 위 쿼리에서 'Error Code: 1071. Specified key was too long; max key length is 3072 bytes'에러가 발생함. 이 에러는 인덱스를 생성할 때 지정된 키의 길이가 너무 길어서 MySQL이 지원하는 최대 키 길이를 초과했음을 나타냄. 위 쿼리에 INDEX가 없지만, UNQUE 제약 조건도 INDEX의 일종이기 때문에 발생.
- UNIQUE 제약조건을 사용하면 MySQL은 해당 열(또는 열의 조합)에 대한 고유 인덱스를 생성하여 데이터의 고유성을 보장함. 이는 해당 열에 중복된 값을 추가하려고 시도할 때 오류를 발생시켜 데이터의 일관성을 유지하는 데 도움을 줌.
- UNIQUE 인덱스는 데이터를 빠르게 조회할 수 있도록 해주며, 동시에 테이블 내에서 각 값이나 값의 조합이 단 하나만 존재하도록 함. 예를 들어, 사용자 이메일 주소나 사용자명과 같이 고유해야 하는 정보에 UNIQUE 제약조건을 사용할 수 있음. 이렇게 하면 데이터베이스가 자동으로 해당 열의 값이 테이블 내에서 유일함을 보장하게 됨.

### 데이터베이스의 일관성을 유지하는 방법
1. 외래 키(Foreign Key) 제약 조건
    - ON DELETE CASCADE: 부모 테이블에서 행이 삭제될 때 해당 행을 참조하는 자식 테이블의 행도 자동으로 삭제됨. 이는 데이터 일관성을 유지하며 참조 무결성을 보장함.
    - ON DELETE SET NULL 또는 ON DELETE SET DEFAULT: 부모 테이블의 행이 삭제될 때 해당 행을 참조하는 자식 테이블의 키 값을 NULL 또는 기본값으로 설정함. 이는 참조가 더 이상 유효하지 않게 되었을 때 데이터 일관성을 유지하는 데 도움이 됨.
2. 트리거(Trigger)
    - 데이터베이스 트리거는 특정 테이블에 대한 삽입, 수정, 삭제 등의 이벤트가 발생할 때 자동으로 실행되는 프로시저. 트리거를 사용하면 복잡한 비즈니스 로직을 구현하고 데이터의 일관성과 무결성을 유지하는 데 도움을 줄 수 있음.
3. 트랜잭션(Transaction)
    - 트랜잭션은 여러 데이터베이스 연산을 하나의 논리적인 단위로 묶어서 처리하는 방법. 트랜잭션은 모든 연산이 성공적으로 완료되거나, 하나라도 실패할 경우 모든 변경 사항을 원래 상태로 되돌리는 '전부 아니면 전무(All or Nothing)'의 원칙을 따름. 이를 통해 데이터의 일관성과 무결성을 보장할 수 있음.
4. 데이터 검증과 정규화
    - 데이터를 데이터베이스에 삽입하기 전에 적절한 검증을 수행하고, 데이터베이스를 정규화하여 데이터 중복을 최소화하는 것도 데이터 일관성을 유지하는 데 중요. 정규화된 데이터베이스 설계는 데이터 무결성을 유지하고, 업데이트 이상(Anomalies)을 방지하는 데 도움을 줌.
5. 애플리케이션 레벨의 일관성 유지
    - 데이터베이스 외에도, 애플리케이션 레벨에서 데이터의 유효성 검사, 오류 처리, 비즈니스 로직의 적절한 구현을 통해 데이터의 일관성을 유지할 수 있음. 애플리케이션 코드에서 데이터의 일관성을 확인하고 관리하는 로직을 포함시키는 것이 좋음.

### CTE
- common table expression
