### SQLite
- 파일 기반의 경량화된 데이터베이스 관리 시스템
- 서버를 설치할 필요 없이 SQL(Structured Query Language)을 사용해 데이터를 관리할 수 있게 해줌.
- 많은 웹 브라우저, 운영 체제, 모바일 애플리케이션 등에서 널리 사용되고 있음.

### 주요특징
- 서버리스: SQLite는 서버를 필요로 하지 않음. 데이터베이스 파일에 직접 액세스하여 작업
- 경량: SQLite는 매우 작은 양의 리소스만을 사용하면서도 효율적으로 동작
- 자체 포함: SQL 데이터베이스 엔진이 외부의 의존성 없이 자체적으로 완전히 동작
- 트랜잭션 지원: ACID(Atomicity, Consistency, Isolation, Durability) 트랜잭션을 완전히 지원
- 다양한 언어 지원: C, Python, PHP 등 다양한 프로그래밍 언어에서 사용할 수 있음
- SQLite는 그 사용의 간편함과 효율성 때문에, 로컬 스토리지가 필요한 애플리케이션, 프로토타입 개발, 경량 애플리케이션, 교육용도 등에서 매우 유용하게 사용됨

### SQLite의 장점
- 경량: 서버가 필요 없고, 간단한 설정과 함께 사용할 수 있어 작은 애플리케이션 또는 프로토타이핑에 이상적
- 휴대성: 단일 데이터베이스 파일로 구성되어 있어, 쉽게 복사하거나 이동할 수 있음
- 서버리스: 별도의 서버 프로세스 없이 애플리케이션에 직접 내장되어 운영되므로, 복잡한 데이터베이스 서버 구성이나 관리가 필요 없음.
- 다중 액세스: 동시성은 제한적이지만, 작은 규모의 애플리케이션에서는 여러 사용자의 액세스를 충분히 처리할 수 있음.
- 광범위한 언어 지원: 대부분의 프로그래밍 언어에서 지원되므로, 다양한 언어로 작성된 애플리케이션에 쉽게 통합할 수 있음

### SQLite의 제한사항

- 동시성: SQLite는 고동시성을 필요로 하는 애플리케이션에는 적합하지 않음. 동시에 많은 수의 사용자가 데이터베이스에 쓰려고 할 때 성능이 저하될 수 있음.
- 대용량 데이터: 대용량 데이터를 처리하거나 매우 복잡한 쿼리를 실행해야 하는 애플리케이션의 경우, SQLite의 성능이 제한적일 수 있음
- 고급 기능 부족: 복제, 클러스터링, 또는 복잡한 트랜잭션 관리와 같은 고급 데이터베이스 관리 기능을 지원하지 않음.

### 적합한 사용 사례

- 개발 및 테스팅: 개발 초기 단계나 단위 테스트를 위해 사용하기에 적합
- 임베디드 애플리케이션 및 모바일 애플리케이션**: 리소스가 제한된 환경에서 운영되는 애플리케이션에 적합
- 작은 규모의 웹 사이트: 저동시성 요구와 작은 데이터 세트를 가진 소규모 웹 사이트에 적합
- 단일 사용자 애플리케이션: 한 번에 한 명의 사용자만 액세스하는 데스크톱 애플리케이션에 적합

### CI/CD 구성할 때 주의사항
- 상황: GitHub Actions를 사용하여 Docker 이미지로 빌드한 후 Amazon ECR(Elastic Container Registry)에 푸시하고, 이후에 EC2(Elastic Compute Cloud)에서 해당 이미지를 풀하여 실행하는 CI/CD 파이프라인
- SQLite는 파일 기반의 데이터베이스이므로, 데이터베이스 파일을 관리하는 방법에 주의해야 함.
1. Docker 이미지 내에 SQLite 데이터베이스 포함: SQLite 데이터베이스 파일을 Docker 이미지 내부에 포함시키는 방법이 가장 간단할 수 있음. 이 경우, 이미지를 빌드할 때 데이터베이스 파일도 함께 빌드에 포함되며, 컨테이너가 시작될 때 이미지 내의 데이터베이스 파일을 사용하게 됨. 하지만 이 방법은 데이터의 지속성(persistence)을 보장하지 못함. 컨테이너가 재시작되거나 새로운 이미지로 업데이트될 때 데이터베이스 내용이 사라질 수 있음.
2. 볼륨을 사용한 데이터 지속성 보장: 데이터의 지속성을 보장하기 위해, Docker 컨테이너와 호스트 시스템 간에 볼륨을 마운트하는 방법을 사용할 수 있음. 이 방법을 사용하면, 데이터베이스 파일이 호스트 시스템의 파일 시스템에 저장되므로, 컨테이너가 삭제되거나 업데이트되어도 데이터는 유지됨. Docker 실행 명령에 볼륨 마운트 옵션을 추가하여 이를 구현할 수 있음.
   예를 들어, EC2 인스턴스에서 컨테이너를 실행할 때 다음과 같은 명령어를 사용할 수 있음:
   ```bash
   docker run -v /path/on/host:/path/in/container image_name
   ```
   여기서 `/path/on/host`는 EC2 인스턴스 내의 데이터베이스 파일을 저장할 경로이고, `/path/in/container`는 컨테이너 내에서 해당 데이터베이스 파일에 접근하기 위한 경로임. 이 방법을 사용하면, 컨테이너 내의 애플리케이션이 SQLite 데이터베이스 파일을 지속적으로 사용할 수 있음.
3. EC2 인스턴스의 백업 및 복구 계획 수립: 데이터의 지속성과 안전성을 위해, EC2 인스턴스 또는 볼륨의 백업을 정기적으로 수행하는 것이 좋음. AWS의 스냅샷 기능을 사용하여 이를 수행할 수 있음. 이를 통해 데이터 손실이 발생했을 때 데이터베이스를 쉽게 복구할 수 있음.
- SQLite를 사용할 때 데이터의 지속성을 확보하는 것은 매우 중요. 따라서, 볼륨을 사용하여 데이터를 영구적으로 저장하고, 정기적인 백업으로 데이터의 안전을 보장하는 것이 좋음.

### FastAPI 예제
- 데이터는 example.db라는 이름의 SQLite 데이터베이스 파일에 저장됨. SQLite는 서버리스 데이터베이스로 작동하며, 모든 데이터를 파일 시스템에 파일 형태로 저장함. 따라서, 이 예제에서는 Python 스크립트가 실행되는 동일한 디렉토리 내에 example.db 파일이 생성되고, 이 파일 안에 모든 데이터베이스 테이블과 데이터가 저장됨.
- SQLite 데이터베이스 파일은 단일 파일로, 데이터베이스와 관련된 모든 것을 포함함. 예를 들어, 테이블, 인덱스, 트리거, 데이터 등이 모두 이 파일 내에 저장됨. 파일 기반의 특성 때문에 SQLite는 데이터베이스를 손쉽게 복사하거나 이동할 수 있으며, 외부 서버 없이 로컬 또는 임베디드 애플리케이션에서 데이터를 관리할 수 있는 효율적인 방법을 제공함.
- get_db_connection 함수에서 sqlite3.connect('example.db')를 호출할 때, 지정된 이름의 데이터베이스 파일이 이미 존재하지 않으면 새 파일이 생성됨. 이미 파일이 존재한다면, 해당 파일에 저장된 데이터베이스에 연결됨.

### SQLite를 임시 데이터베이스로 사용
- 추후 MySQL을 사용할 것이지만 SQLite를 임시 데이터베이스로 사용하는 것은 개발 초기 단계에서 매우 흔한 접근 방식
- SQLite와 MySQL 사이에는 몇 가지 중요한 차이점이 있지만, 개발 과정에서 데이터 모델링 및 애플리케이션 로직을 테스트하는 데 있어 SQLite는 간편하고 빠르게 설정할 수 있는 좋은 선택입
- 다만, 나중에 MySQL로의 전환을 염두에 두고 개발을 진행해야 함.

- SQLite와 MySQL 사용 시 고려할 점들:
   - 데이터 유형 호환성: SQLite와 MySQL은 데이터 유형을 다르게 처리할 수 있으므로, 이전 과정에서 호환성 문제가 발생하지 않도록 주의해야 함.
   - 동시성 및 잠금: SQLite는 동시 쓰기 작업에 비해 읽기 작업에서 더 높은 성능을 제공함. 대규모 사용자나 복잡한 쿼리가 많은 애플리케이션의 경우 MySQL이 더 적합할 수 있음.
   - 트랜잭션 관리: MySQL은 더 복잡한 트랜잭션 관리 옵션을 제공함. SQLite도 트랜잭션을 지원하지만, 사용 사례에 따라 MySQL이 더 나은 선택일 수 있음.
      - TODO: FastAPI에서 MySQL을 사용할 때는 자주 사용되지만, SQLLite에서는 되지 않는 기능 알아보기
   - 마이그레이션 계획: 나중에 MySQL로의 전환을 원활하게 하기 위해, 데이터베이스 스키마와 애플리케이션 코드를 가능한 한 데이터베이스에 독립적으로 유지하는 것이 좋음. ORM (Object-Relational Mapping) 라이브러리를 사용하면 이러한 전환을 쉽게 할 수 있음.
      - TODO: 추가 설명 필요
- FastAPI와 함께 SQLite를 사용하는 초기 설정 과정
   1. FastAPI 프로젝트 생성
   2. SQLite 데이터베이스 파일 설정
   3. ORM 라이브러리를 통한 데이터베이스 모델 정의: SQLAlchemy 같은 ORM 라이브러리를 사용하면, 나중에 MySQL 같은 다른 데이터베이스로 쉽게 전환할 수 있음.
   4. 데이터베이스 CRUD (생성, 읽기, 업데이트, 삭제) 오퍼레이션 구현
   5. FastAPI 엔드포인트를 통한 데이터 액세스 및 조작
- SQLite를 사용할 때는 서버의 디스크에 데이터베이스 파일이 저장되므로, 클라우드 환경에서는 데이터베이스 파일에 대한 접근과 백업 전략을 고려해야 함.
- SQLite를 사용하는 것은 개발 초기 단계에서 좋은 접근 방식이며, 추후 MySQL 같은 더 강력한 데이터베이스 시스템으로의 전환이 계획된 경우에도 유용함.

### SQLite가 MySQL가 다르게 데이터를 처리하는 경우
- 문자열 및 텍스트 데이터 유형
   - MySQL에서는 VARCHAR, TEXT, CHAR 등 다양한 문자열 유형을 구분하여 사용
   - SQLite에서는 모든 문자열 데이터는 단순히 TEXT로 저장됨
- 정수 데이터 유형
   - MySQL에서는 TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 등의 정수 유형을 제공
   - SQLite에서는 모든 정수가 단순히 INTEGER로 처리됨
- 실수 데이터 유형
   - MySQL에서는 FLOAT, DOUBLE, DECIMAL 등 실수를 저장하기 위한 몇 가지 유형을 제공
   - SQLite에서는 REAL을 사용하여 실수를 저장
- 날짜 및 시간 데이터 유형
   - MySQL은 DATE, DATETIME, TIMESTAMP, TIME, YEAR 등의 날짜 및 시간 유형을 제공
   - SQLite에서는 TEXT (ISO8601 문자열), REAL (Julian day numbers), INTEGER (Unix Time, 즉, 1970년 1월 1일부터의 초 단위 시간) 등의 형식을 사용하여 날짜와 시간을 저장할 수 있음
- 불리언 데이터 유형
   - MySQL에서는 BOOLEAN 혹은 BOOL 유형이 실제로는 TINYINT(1)의 별칭으로 사용됨
   - SQLite에서는 불리언 값이 INTEGER 유형을 사용하여 저장됨. 여기서 0은 FALSE, 1은 TRUE를 나타냄.
- BLOB 데이터 유형
   - 두 데이터베이스 시스템 모두 바이너리 데이터를 저장하기 위한 BLOB 유형을 제공하지만, 처리 방식에 약간의 차이가 있을 수 있음.

### SQLAlchemy 모델에서의 데이터 유형 처리
- DATETIME: SQLAlchemy의 DateTime 필드는 MySQL에서는 DATETIME 유형으로, SQLite에서는 내부적으로 TEXT, REAL, 또는 INTEGER로 저장될 수 있는 날짜와 시간 정보로 변환됨.
- INT: Integer 유형은 SQLite와 MySQL 모두에서 잘 작동함. SQLite는 저장된 값에 따라 다양한 크기의 정수를 동적으로 처리할 수 있으며, MySQL에서는 지정된 Integer 유형(TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT)에 따라 저장됨

### 호환성
- SQLite와 MySQL 모두에서 SQLAlchemy 모델을 사용할 때, SQLAlchemy는 사용 중인 데이터베이스 엔진에 적합한 방식으로 데이터 유형을 처리함. 
- 따라서, Pydantic의 BaseModel을 상속받아 생성된 스키마 모델과 별개로, SQLAlchemy 모델에 정의된 데이터 유형(DATETIME, INT 등)은 SQLite에서도 호환되도록 처리됩니다.

### SQLite를 사용할 때 SQLAlchemy 모델에서 정의된 데이터 유형(DATETIME, INT 등)의 호환성과 관련된 주의사항
- 데이터 유형의 자동 변환: SQLite에서는 데이터 유형이 더 유연하기 때문에, 예를 들어 DATETIME이 TEXT로 저장될 때, 정확한 포맷을 유지하는 것이 중요함. 이를 위해 SQLAlchemy 모델에서 DateTime 유형을 사용할 때는 일관된 날짜/시간 포맷을 사용하도록 주의해야 함.
- 인덱싱과 성능: 데이터 유형의 자동 변환은 편리하지만, 특히 대규모 데이터를 다룰 때는 인덱싱 전략과 성능에 영향을 줄 수 있음. SQLite에서 특정 데이터 유형으로의 명시적 변환을 선호할 수 있음.
- 마이그레이션 계획: 나중에 SQLite에서 MySQL로 마이그레이션할 계획이라면, 데이터 유형과 관련된 차이점을 미리 고려하고, 가능한 문제점을 사전에 해결하는 것이 좋음.


====================================================================================================

## SQLite 핵심
1. SQLite 개요
   - 경량의 파일 기반 데이터베이스
   - 서버가 필요 없는 임베디드 데이터베이스
   - 단일 파일에 모든 데이터를 저장
   - 간편한 설정과 관리
   - 중소규모 애플리케이션에 적합
2. SQLite 설치 및 사용
   - Python에는 기본적으로 SQLite가 내장되어 있음
   - `import sqlite3`로 SQLite 모듈 불러오기
   - `sqlite3.connect('database.db')`로 데이터베이스 연결
   - 연결 객체의 `cursor()` 메서드로 커서 생성
   - 커서의 `execute()`로 SQL 쿼리 실행
   - 연결 객체의 `commit()`으로 변경 사항 저장
   - 사용 후 연결 객체의 `close()`로 연결 종료
3. 테이블 생성 및 스키마 정의
   - `CREATE TABLE` 문을 사용하여 테이블 생성
   - 각 열의 이름과 데이터 타입 지정
   - 기본 키, 외래 키, 제약 조건 등을 정의
   - SQLite는 동적 타입을 지원하여 데이터 타입이 유연함
4. CRUD 작업
   - `INSERT` 문으로 데이터 삽입
   - `SELECT` 문으로 데이터 조회
   - `UPDATE` 문으로 데이터 수정
   - `DELETE` 문으로 데이터 삭제
   - 기본적인 SQL 문법과 유사
5. 인덱싱과 쿼리 최적화
   - 인덱스를 사용하여 쿼리 성능 향상
   - `CREATE INDEX` 문으로 인덱스 생성
   - 적절한 인덱스를 사용하여 검색 속도 개선
   - 복잡한 쿼리의 경우 `EXPLAIN` 문으로 쿼리 실행 계획 확인
6. 트랜잭션 처리
   - 트랜잭션을 사용하여 데이터 무결성 보장
   - `BEGIN`, `COMMIT`, `ROLLBACK` 문으로 트랜잭션 제어
   - 충돌 해결을 위한 동시성 제어 메커니즘 제공
7. FastAPI와의 통합
   - SQLite 데이터베이스 연결 및 종속성 주입
   - FastAPI의 Pydantic 모델을 사용하여 데이터 유효성 검사
   - SQLAlchemy 등의 ORM을 활용하여 데이터베이스 작업 단순화
   - 요청 핸들러에서 데이터베이스 쿼리 실행
8. 데이터 백업 및 복원
   - SQLite 데이터베이스 파일 복사로 간단한 백업 가능
   - `sqlite3` 명령행 도구를 사용하여 데이터 덤프 및 복원
   - 정기적인 백업 수행으로 데이터 손실 예방
9. 제한 사항 및 고려 사항
   - 대용량 데이터나 높은 동시성 처리에는 적합하지 않을 수 있음
   - 복잡한 쿼리나 고급 SQL 기능은 제한적일 수 있음
   - 데이터 무결성과 일관성을 위해 적절한 제약 조건 설정 필요
   - 백업 및 복제 전략 수립 필요
10. 추가 리소스
    - SQLite 공식 문서 참조: https://www.sqlite.org/docs.html
    - Python SQLite3 모듈 문서 참조: https://docs.python.org/3/library/sqlite3.html
    - FastAPI 공식 문서의 데이터베이스 관련 섹션 참조: https://fastapi.tiangolo.com/tutorial/sql-databases/

====================================================================================================
