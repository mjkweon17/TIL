## 23년 12월 10일

1. dependency
    - 요청 처리에 필요한 데이터나 기능을 캡슐화하고 재사용하기 위해 만듦
    - 예를 들어, 특정 요청이 사용자의 인증 정보를 필요로 한다면, 이를 검증하는 Dependency를 만들어 사용할 수 있음. 이렇게 하면 동일한 인증 로직을 여러 라우팅 함수에서 재사용할 수 있음.
    - Dependency를 만드는 방법
        - Dependency 함수 정의: Dependency는 함수로 정의됨. 이 함수는 필요한 데이터를 반환하거나, 조건이 충족되지 않을 경우 예외를 발생시킴. 이 때, 함수의 매개변수로 FastAPI의 Depends를 사용할 수 있음.
            ```python
            from fastapi import Depends, HTTPException

            def verify_token(token: str):
                if not token or token != "mysecrettoken":
                    raise HTTPException(status_code=400, detail="Invalid token")
                return token
            ```
        - 라우팅 함수에서 Dependency 사용: 정의한 Dependency를 라우팅 함수에서 사용함. 이 때, 함수의 매개변수로 Depends와 함께 Dependency 함수를 지정함.
            ```python
            from fastapi import FastAPI

            app = FastAPI()

            @app.get("/items/")
            async def read_items(token: str = Depends(verify_token)):
                return {"token": token}
            ```
        - Dependency 호출: FastAPI는 요청을 처리할 때 Depends를 사용하여 지정된 Dependency 함수를 자동으로 호출함. 함수가 예외를 발생시키면 요청은 거부되고, 그렇지 않으면 반환된 값이 라우팅 함수의 매개변수로 절달됨.
2. service.py와 utils.py의 차이
    - service.py와 utils.py에 들어가는 함수의 주요 차이점은 그 함수들의 책임 범위와 재사용성에 있음
    - service.py
        - 특정 비즈니스 로직이나 도메인 로직을 처리하는 함수들을 담음
        - 이러한 함수들은 주로 어플리케이션의 핵심 기능을 구현하며, 특정 도메인이나 비즈니스 요구 사항에 종속적
        - 예: 사용자 인증, 토큰 생성, 데이터베이스에서 사용자 정보 검색 등의 작업을 수행하는 함수들
    - utils.py
        - 일반적인, 재사용 가능한 함수들을 담음
        - 이러한 함수들은 도메인이나 비즈니스 로직에 종속적이지 않고, 다양한 상황에서 재사용할 수 있음
        - 예: 날짜 형식 변환, 문자열 검증, 이메일 형식 확인 등의 작업을 수행하는 함수들
    - service.py는 어플리케이션의 핵심 로직을, utils.py는 범용적으로 사용할 수 있는 헬퍼 함수나 유틸리티 함수
3. BackgroundTasks
    - HTTP 응답을 보내고 난 후에 백그라운드에서 실행될 작업들을 추가하는데 사용
    - 비동기적으로 처리해야 하는 작업, 예를 들어 이메일 발송이나 데이터베이스의 업데이트 등을 처리하는 데 유용
    - BackgroundTasks를 사용하면 클라이언트는 요청에 대한 응답을 더 빠르게 받을 수 있음. 왜냐하면 주요 처리 작업이 완료된 즉시 응답을 보낼 수 있고, 나머지 작업은 백그라운드에서 계속 실행되기 때문
    ```python
    from fastapi import BackgroundTasks, FastAPI

    app = FastAPI()

    def write_log(message: str):
        with open("log.txt", mode="a") as log:
            log.write(message)

    @app.post("/send-notification/{message}")
    async def send_notification(message: str, background_tasks: BackgroundTasks):
        background_tasks.add_task(write_log, message)
        return {"message": "Notification sent in the background"}
    ```
4. refresh token
    - 발급 과정과 저장 과정: 사용자가 처음으로 로그인하면, 서버는 사용자의 인증 정보를 확인하고 액세스 토큰(Access Token)과 리프레시 토큰을 발급함. 그리고 이 두 토큰은 사용자의 클라이언트 애플리케이션에 전달됨. 리프레시 토큰은 일반적으로 DB에 저장되며, 이는 나중에 액세스 토큰을 재발급하는 데 사용됨.
    - 리프레시 토큰 사용 과정: 액세스 토큰은 일반적으로 수 시간 후에 만료되며, 이는 보안을 위해 의도적으로 짧게 설정되어 있음. 토큰이 만료되면, 사용자는 다시 로그인해야 하는 불편함이 있음. 이러한 문제를 해결하기 위해 리프레시 토큰이 사용됨. 액세스 토큰이 만료될 때, 클라이언트 애플리케이션은 저장된 리프레시 토큰을 서버에 전달하고, 서버는 이를 검증한 후 새로운 액세스 토큰을 발급해 줌.
    - 리프레시 토큰을 통해 할 수 있는 것: 리프레시 토큰은 주로 액세스 토큰을 재발급하는 데 사용되지만, 사용자의 세션을 관리하는 데도 활용될 수 있음. 예를 들어, 사용자가 로그아웃하면, 해당 사용자의 리프레시 토큰을 DB에서 삭제하면 됨. 이렇게 하면, 사용자는 더 이상 자동 로그인할 수 없게 됨. 또한, 리프레시 토큰이 만료되거나, 토큰이 유효하지 않게 되면, 사용자는 다시 로그인해야 함.
    - 리프레시 토큰의 보안성: 리프레시 토큰은 보안성이 매우 중요함. 만약 리프레시 토큰이 탈취되면, 공격자는 사용자의 세션을 계속 유지하거나 새로운 액세스 토큰을 얻어 사용자의 권한을 이용할 수 있음. 따라서 리프레시 토큰은 안전하게 저장되어야 하며, HTTPS와 같은 보안 프로토콜을 통해 전송되어야 함.
    - 리프레시 토큰의 생명 주기: 리프레시 토큰은 일반적으로 액세스 토큰보다 긴 생명 주기를 가짐. 하지만 무제한으로 유효한 리프레시 토큰을 발급하는 것은 보안상 좋지 않음. 따라서 리프레시 토큰도 일정 기간 후에는 만료되도록 설정하는 것이 일반적. 또한, 리프레시 토큰을 이용해 액세스 토큰을 재발급할 때마다 새로운 리프레시 토큰을 발급하여 이전의 리프레시 토큰을 무효화하는 방식을 사용하기도 함.
    - 토큰 기반 인증의 단점: 토큰 기반 인증에는 리프레시 토큰과 액세스 토큰이라는 두 가지 토큰을 관리해야 한다는 단점이 있음. 이는 서버와 클라이언트 모두에게 추가적인 구현 복잡성을 불러옴. 또한, 토큰이 탈취되는 등의 보안 문제가 생길 수 있으므로, 토큰을 안전하게 관리하고 사용하는 것이 중요함.
5. await
    - 비동기 함수가 다른 비동기 함수를 호출할 때 사용하는 키워드
    - 이 키워드를 사용하면 호출된 비동기 함수가 완료될 때까지 기다릴 수 있음
    - 일반 함수 앞에 await를 붙이면 에러가 발생함
    - 동기 블로킹 함수라면 await를 붙이는 것은 별 도움이 되지 않음
    - 함수가 I/O 작업을 많이 수행하고, 이를 비동기로 처리하면 성능향상이 이루어질 수 있다면, 해당 함수를 비동기 함수로 바꾸고 await를 붙이는 것이 좋음
6. 동기 블로킹 함수
    - 프로그램이 해당 함수를 호출하면, 그 함수가 종료될 때까지 프로그램의 실행이 멈추는, 즉 "블록(block)"되는 함수를 의미
7. 일반 def 함수를 사용하는 것이 더 효율적인 경우
    - 단순 계산 작업: 만약 함수가 복잡한 계산을 수행하는 경우, 이는 I/O 작업이 아니므로 비동기로 처리할 필요가 없음. 이런 경우 일반 def 함수로 선언하는 것이 더 효율적일 수 있음.
    - CPU 바운드 작업: CPU 자원을 많이 사용하는 작업, 예를 들어 이미지 처리나 머신러닝 모델의 학습 등은 CPU 바운드 작업에 해당함. 이런 작업은 비동기로 처리하더라도 성능 향상을 기대하기 어려움. 이런 경우에도 일반 def 함수로 선언하는 것이 더 적합함.
    