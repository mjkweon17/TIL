## 23년 8월 14일

### Dajeong
1. 칸반 보드
    - 팀의 업무를 시각화한 프로젝트 관리의 한 형태
    - 팀이 업무와 각 팀원이 할 수 있는 작업량 간에 밸런스를 맞추는 도구
    - 업무량과 워크플로우를 더 효과적으로 시각화해 프로젝트를 관리함
    - 도요타는 칸반을 활용하여 제조 프로세스를 Push(제품을 시장으로 밀어냄)에너 Pull(시장 수요에 따라 제품 생산)로 변화시켜 시장 경쟁력을 유지하면서 재고 수준을 낮추는데 사용함
    - 요소:  시각적 신호, 열, 진행중인 작업 제한, 이행 약속 시점, 배포 시점
        - 시각적 신호
            - 시각적 카드
            - 카드 하나당 하나씩 모든 프로젝트와 작업 항목을 기록함
        - 열
            - 특정 활동을 나타내는 열. 열들이 모여 워크 플로우를 구성함
            - '해야 할 일', '진행 중', '완료'와 같이 간단하거나 더 복잡할 수 있음
        - WIP(진행중인 작업) 제한
            - 지정된 시간에 한 열에 포함할 수 있는 최대 카드 수
            - 3개 이상 포함하지 않는 것이 이상적
            - 열에 카드의 수가 '최대치'에 도달하면 팀은 먼저 최대치에 도달한 카드를 해결하고 다음 단계로 보내야 함
            - 워크플로에서 병목 현상을 노출시키고 흐름을 최대하하는 데 매우 중요한 역할을 함
        - 이행 약속 시점
            - 팀에서 아이디어를 선택하여 프로젝트에서 작업을 시작하는 시점
            - 백로그에 고객 또는 팀원이 프로젝트에 대한 아이디어를 제시하고, 팀은 준비가 되면 백로그에서 이슈를 작업하기 시작함
            - 약정 시점: 팀에서 아이디어를 선택하여 프로젝트에서 작업을 시작하는 시점
        - 제공 시점
            - 워크 플로우의 끝으로 대부분의 팀에서 서비스나 제품을 제공하는 시점
            - 리드 타임: 약정 시점에서 제공 시점 사이의 경과 시간
    - 칸반의 두 가지 규칙
        - 진행 중인 작업을 제한
        - 작업을 시각화하는 것
    - 규칙을 많이 추가할수록 맞는 맥락이 줄어들기 때문에 이 두 가지 규칙으로 시작하는 것이 좋음
    - https://boardmix.com/kr/skills/learn-about-kanban/
    - https://www.atlassian.com/ko/agile/kanban/boards
2. 사용자 스토리
    - 최종 사용자의 관점에서 작성한 소프트웨어 기능에 대한 일반적인 비공식 설명
    - 목적
        - 소프트웨어 기능이 고객에게 가치를 제공하는 방법을 명확히 설명하는 것
        - 어떤 작업이 고객에게 특정 가치를 제공하는 방법을 명확히 설명하는 것.
    - 사용자 스토리는 애자일 프레임워크에서 가장 작은 작업 단위
    - 소프트웨어 사용자의 관점에서 표현한 최종 목표이며 기능이 아님
    - https://www.atlassian.com/ko/agile/project-management/user-stories
3. 고객
    - 내부 고객: 컨설팅펌에서 보고서를 만들어 대외비로 내부자들끼리 공유할 때, 이 보고서를 읽는 사람들
    - 외부 고객: 만들어진 보고서를 제공받는 클라이언트
    - 내부 서비스 법칙에 의하면 외부 고객에 대한 서비스 수준은 내부 고객의 서비스 수준을 초과할 수 없으므로, 내부 고객에 대한 인식을 하고 내부 고객에게 좋은 경험과 서비스를 제공한다면 프로그램 품질이 향상될 수 있음
    - https://namu.wiki/w/%EA%B3%A0%EA%B0%9D
4. 백로그
    - 한 팀이 일정 기간 또는 일정 시간 안에 해야 할 모든 업무를 작성한 문서
        - 업무 개선 아이디어, 제품 개발 관련 업무, 회고, 학습 리뷰, 사후 분석 모두 포함됨
    - 개발해야 할 기능 또는 제품에서 요구하는 기능과 우선순위
    - '누가' '어떤 문제'를 겪고 있는지, 그래서 우리가 '문제를' '어떻게 해결'할 수 있을지, 그 문제를 해결함으로써 '얻게 되거나 기대하는 결과'는 무엇인지를 명시해야 함 -> 이렇게 백로그를 정리해야 추후 팀에서 백로그를 선정할 때 우선순위를 선정하기가 쉽고, 함께 서비스를 만들 팀원을 설득하기가 쉬움
    - 비즈니스 요구 사항을 파악하고 그에 따라 백로그 내 업무의 우선순위를 설정 -> 우선순위가 설정된 백로그가 투명하게 공개돼 있음 -> 엔지니어는 다음에 할 작업이 무엇인지 문의하지 않아도 됨
    - 백로그는 팀에서 주기적으로 논의하고 선정해서 관리할 수 있어야 함
5. 우선순위 선정 방법
    - MoSCoW 방법
        - Must Have: 서비스 운영에서 이 기능을 뺴고는 온전한 서비스라고 생각하기 어려운 기준. 서비스 자체에 치명적인 영향을 끼치거나 시급성이 높아서 반드시 해결해야 할 기능
        - Should Have: 서비스를 운영하는 데 있어서 당장 적용하지 않아도 서비스에 영향이 없는 기능 중 우선순위가 높은 기준
        - Could Have: 서비스를 운영하는 데 있어서 전혀 영향이 없는 기능 중 우선순위가 낮은 기준. '있으면 좋고, 없어도 상관없는' 기준으로 정리됨.
        - Won't have: 서비스를 운영하는 데 있어서 전혀 영향이 없으며, ㅜ선순위가 가장 낮은 기준. 중요도도 떨어지고, 적용햇을 때 효과도 아주 미미한 수준의 기능
    - RICE 방법
        - Reach: 얼마나 많은 수의 사용자에게 도달하며, 그들에게 영향이 미치는지에 대한 기준. 백로그를 통해 개발될 기능이 특저 기간 동안에 얼마나 많은 사용자가 사용할 수 있는지를 말함. 서비스의 실질적인 지표인 DAU, MAU같은 수치로 평가할 수 있음
        - Impact: 도달하게 될 사용자들이 해당 기능을 사용할 때 얼마나 큰 영향을 받게 되는지에 대한 기준. 측정하기에 따라 매우 다르고, 명확한 기준을 수립할 수 없음. 영향의 척도를 5단계 정도로 구분해서 상대적인 점수를 부여하는 것이 일반적. 
            - 3점: 효과가 매우 큼, 2점: 효과가 큼, 1점: 효과가 중간, 0.5점: 효과가 낮음, 0.25점: 효과가 매우 낮음
        - Confidence: 개발하게 될 기능이 성공할지에 대해 얼마나 확신을 가지는지에 대한 기준. 만들게 될 기능이 사용자에게 얼마나 만족스러운 가치를 전달하는지에 대한 것. 크게 3단계로 구분해서 점수를 적용
            - 100%: 높은 신뢰도, 80%: 중간 신뢰도, 50%: 낮은 신뢰도
        - Effort: 백로그를 개발하는 과정에서 시간이나 인력이 얼마나 소요되는지에 대한 기준. 시간이나 인력 소요를 평가 기준으로 사용할 수도, 계산이 용이하도록 4단계 점수를 적용할 수도 있음
            - 4점: 매우 큰 수준의 노력, 3점: 큰 수준의 노력, 2점: 중간 수준의 노력, 1점: 적은 수준의 노력
        - RICE점수: 각 항목에 대해 점수를 부여했다면 최종적으로 RICE 점수를 계산해서 백로그에 적용.
            - RICE 점수 = R * I * C / E
            - RICE 점수가 클수록 우선순위가 높은 백로그
    - 여러 개의 우선순위 선정 방법은 혼합해서 사용하기도 하고, 회사나 조직에 맞춘 우선순위 선정방법을 개발해서 사용하기도 함
    - '한정된 리소스'로 '최고의 결과'를 만들 수 있도록 우선순위를 선정하는 것이 제일 중요!
    - https://brunch.co.kr/@mojuns/36
    - https://www.ciokorea.com/tags/5313/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84/157342
6. Data-Driven Business Decisions
    - 작업에 대한 우선순위를 둘 때 data로 시작하는 것이 가장 좋음
    - 그러기 위해서는 spreadsheet problem으로 만드는 것이 필요
    - 
    - https://www.cio.com/article/193380/make-it-a-spreadsheet-problem.html
7. 던바의 수
    - 인간이 안정적으로 관계를 형성할 수 있는 적정한 수. 일반적으로 평균치인 150명.
    - 150~200명, 사회성이 뛰어난 상위 2%인 경우 230까지
    - https://namu.wiki/w/%EB%8D%98%EB%B0%94%EC%9D%98%20%EC%88%98
8. 정보 빙산 이론
    - information iceberg theory
    - 팀 리더는 프론트라인 관련 문제의 74% 밖에 인지하지 못함. 더 위로 올라갈 경우 누락되는 정보가 많음
    - 관리자
        - 팀 회의에서  제대로 우선순위가 정립된 백로그가 어떤 모습일지 의견을 듣고, 논의하고, 절충하는 과정이 필요
        - 미팅 전에 모든 업무를 검토하고, 이를 다른 관리자에게 확인하는 등의 일을 하라는 것은 아님
        - 질문에 답변할 수 있고 회의가 원활하게 진행될 수 있도록 필요한 정보를 준비해서 회의에 참여 -> 엔지니어들은 회의로 시간 보내는 것을 선호하지 않음
8. PM/PO
    - PM(Product Manager)
    - PO(Product Owner)

### AI News

### IT News

### AI

### Algorithm

### Computer Science

### KuccLib
1. import statement
    - 모듈을 import하는 부분
2. datetime
    - 날짜와 시간을 조작하는 클래스
    - 날짜와 시간 산술이 지원됨
    - https://docs.python.org/ko/3/library/datetime.html
3. repr()
    - str()처럼 객체를 문자열로 반환하는 함수
    - str(): 프로그램 사용자(end user)를 위해, 사용자가 보기 쉽도록, 비공식적인 문자열을 출력
    - repr(): 프로그램 개발자(developer)를 위해, 문자열로 객체를 다시 생성하도록, 공식적인 문자열을 출력
    - https://wikidocs.net/134994
4. eval()
    - 매개변수로 받은 expression을 문자열로 받아서, 실행하는 함수 -> 매개변수로 받은 expression은 파이썬에서 실행 가능한 문자열로 들어와야 한다는 것
    - expression(식): 하나 이상의 값으로 표현될 수 있는 코드
     - input 함수를 이용해서 사용자로부터 원하는 파이썬 함수를 입력 받거나 식을 입력 받아서 마음대로 프로그램을 조종할 수 있음
        - 사용자가 마음대로 프로그램을 조종할 수 있다 = 프로그램에 명령을 입력할 수 있다 = 프로그램을 상처입히거나 해킹할 수 있음
    - https://blockdmask.tistory.com/437
5. Rust
    - C/C++와 동등한 수준의 속도를 유지하면서 안전성과 동시성을 향상시키는 것을 목표로 설계됨
    - pydantic도 rust도 쓰여서 python의 data validation 라이브러리들 중 속도가 가장 빠름
6. Github - Issue
    - 프로젝트의 기획, 작업, 개선 사항, 버그 수정, 새로 추가될 기능 등 모든 것
    - GitHub에서는 이 모든 활동에 대해 이슈를 등록하고 그것을 기반으로 작업을 진행할 수 있음
    - Jira에서 이슈를 생성해 작업을 진행하는 것과 같고, 그 외에도 이슈 open, close 개념이 같음
    - 절차(출처: ChatGPT)
        1. 이슈 제목과 설명 작성: 이슈 제목은 명확하고 간결하게 작성하며, 이슈 설명에서는 API 추가의 목적과 요구 사항을 자세하게 서술합니다.
        2. 라벨과 마일스톤 지정: 프로젝트의 복잡성에 따라 라벨을 지정하여 이슈의 유형을 나타낼 수 있습니다. 또한, 마일스톤을 설정하여 작업을 추적하고 계획을 세울 수 있습니다.
        3. 할당 및 참여자 추가: 해당 작업을 담당할 사람을 할당하거나, 이슈와 관련된 다른 참여자를 추가할 수 있습니다.
        4. 댓글 및 토론: 이슈에 댓글을 달아서 추가 의견이나 질문을 제시하고, 다른 참여자들과 토론을 진행할 수 있습니다.
        5. 링크 및 참조: 이슈 내에서 관련된 문제나 풀 리퀘스트(PR), 커밋 등을 참조하거나 링크할 수 있습니다.
        6. 작업 진행 상황 업데이트: 작업이 진행될 때마다 상황을 업데이트하고 관련 정보를 추가할 수 있습니다.
7. GitHub - Project
    - 작업의 진행도를 한 눈에 볼 수 있고, 이슈들을 하나의 작업(task)로 나타내서 그 작업이 어느정도 진행되었는지 확인하고 관리할 수 있는 메뉴
    - 원하는 뷰 형식을 고를 수 있으며, 일반적으로 칸반 보드 형태로 사용함
    - https://velog.io/@dohaeng0/GitHub-Project-Issue-%ED%99%9C%EC%9A%A9
8. CORS
    - 웹 브라우저는 보안 상의 이유로 다른 도메인으로부터 오는 리소스 요청을 차단함. 하지만, 웹 앱은 종종 다른 도메인으로부터의 요청이 필요한 경우가 있음. 이때 CORS를 사용하여 특정 도메인들로부터의 요청을 허용할 수 있음
    - origins 리스트에는 허용하려는 도메인 주소들을 포함함. 이 주소들은 프로토콜 (http 또는 https)와 도메인 이름, 포트 번호까지 포함하여 지정함. 목록에 있는 주소 중 하나가 클라이언트 애플리케이션의 주소와 일치하면, 해당 클라이언트는 서버로부터 리소스를 요청할 때 CORS 제약 조건을 통과하게 됨.
    - 출처: ChatGPT
9. CORS preflight requests
    - CORS 사전 요청
    - 웹 브라우저가 JavaScript 코드로 실행되는 교차 출처 요청이 안전하고 허가된 것인지 확인하기 위해 구현된 보안 기능
    - 특정 종류의 교차 출처 요청을 실행하기 전에 브라우저에 의해 자동으로 전송되는 특정 유형의 HTTP 요청
    - 실제 요청이 서버의 CORS 정책에 따라 허용되는지 확인하기 위해 서버와 통신하는 역할을 함
    - 사전 요청 프로세스
        1. 사전 요청: 특정 특성(예: GET, POST, HEAD 이외의 HTTP 메서드 사용 또는 사용자 지정 헤더 포함)으로 교차 출처 요청이 이루어질 때 브라우저는 자동으로 서버로 HTTP OPTIONS 사전 요청을 보냅니다. 이 사전 요청에는 Origin, Access-Control-Request-Method, Access-Control-Request-Headers 헤더가 포함됩니다.
        2. 서버 처리: 서버는 사전 요청을 받아들이고 CORS 정책을 확인합니다. 서버는 허용된 출처(Access-Control-Allow-Origin), 허용된 메서드(Access-Control-Allow-Methods), 허용된 헤더(Access-Control-Allow-Headers)를 나타내는 적절한 CORS 헤더를 응답으로 보내야 합니다.
        3. 브라우저 결정: 브라우저는 서버로부터의 응답을 확인합니다. 서버의 CORS 헤더가 실제 요청을 허용하면 브라우저는 실제 교차 출처 요청을 진행합니다. 헤더가 정책과 일치하지 않거나 없는 경우 브라우저는 잠재적인 보안 위험을 방지하기 위해 실제 요청을 차단합니다.
        4. 실제 요청: 사전 요청이 성공적이고 서버의 CORS 정책이 허용하는 경우 브라우저는 실제 교차 출처 요청(GET, POST, PUT 등)과 적절한 헤더를 함께 보냅니다. 서버는 이 요청을 동일 출처 요청과 마찬가지로 처리합니다.
    - CORS 사전 요청을 처리하려면 서버 측 구성이 필요함. CORS를 처리하는 방법은 사용하는 서버 기술(예: Apache, Nginx, Node.js 등)에 따라 다르며, 대부분의 현대적인 웹 프레임워크는 CORS를 처리하는 내장 기능을 제공하여 구성 프로세스를 간소화함
    - 출처: ChatGPT
10. 실제 배포 환경에서 보안을 위해 CORS와 관련하여 고려할 사항
    1. 보안 강화를 위한 Origins 제한: 현재 코드에서는 허용된 Origin만 설정하고 있습니다. 이는 기본적으로는 좋지만, 보안을 강화하기 위해 허용할 Origin을 더 제한할 수 있습니다. Frontend 애플리케이션의 배포된 도메인만을 허용하도록 설정하는 것이 좋습니다.
    2. 환경별 Origins 설정: origins 리스트에는 로컬 환경을 위한 주소만 포함되어 있습니다. 실제 운영 환경에서는 배포된 프론트엔드 애플리케이션의 주소를 추가해야 합니다.
    3. Preflight 요청 처리: 클라이언트에서 허용된 메서드나 헤더 외의 다른 요청을 보낼 때, CORS는 프리플라이트(preflight) 요청을 보냅니다. 이 요청에 대한 응답을 제대로 처리하도록 설정되어야 합니다. FastAPI의 경우, OPTIONS 메서드에 대한 핸들러를 구현하여 프리플라이트 요청을 처리할 수 있습니다.
    4. 보안 토큰 설정: 현재 코드에 JWT 토큰을 사용한다고 나와있습니다. 이 경우 토큰을 안전하게 전달하고 관리하기 위한 보안 설정도 고려해야 합니다. HTTPS를 사용하거나, 토큰을 안전한 방식으로 저장하고 전달하는 것이 중요합니다.
    5. HTTPS 사용: 보안을 강화하기 위해 애플리케이션을 HTTPS로 서비스하는 것이 좋습니다. 이를 위해서는 SSL 인증서를 획득하고 서버를 HTTPS로 설정해야 합니다.
    6. 에러 처리와 로깅: 어플리케이션의 안정성을 높이기 위해 에러 처리와 로깅을 적절히 구현하는 것도 중요합니다. FastAPI는 에러 핸들링과 관련된 유용한 기능을 제공합니다.
    7. 보안 업데이트와 의존성 관리: 사용하고 있는 FastAPI, 라우팅에 사용하는 패키지, 그리고 다른 의존성 패키지들을 주기적으로 업데이트하여 보안 취약점에 노출되지 않도록 관리해야 합니다.
    8. API 버전 관리: 애플리케이션의 변경 사항이나 API 업데이트에 대한 관리를 위해 버전 관리를 신중하게 수행해야 합니다.
    9. 보안 테스트: 보안 상의 취약성을 확인하기 위해 정기적인 보안 테스트를 수행하고 취약점을 해결해야 합니다.
    - 출처: ChatGPT
11. serialization
    - 직렬화
    - 데이터를 다른 형식으로 변환하는 프로세스
    - 데이터는 원래의 구조와 형식을 유지하면서 다른 형식으로 변환됨
    - 주로 데이터를 네트워크를 통해 전송하거나 저장하는 등의 상황에서 사용됨
    - 출처: ChatGPT
12. coercion
    - 일반적으로 다른 데이터 유형 간에 연산이나 할당을 수행할 때 자동으로 한 데이터 유형을 다른 데이터 유형으로 변환하는 과정
    - 주로 프로그래밍 언어에서 찾을 수 있는 개념으로, 언어나 프레임워크가 호환되지 않는 데이터 유형을 변환하여 연산의 의도를 보존하려고 시도함
    - 암시적 코어션:  프로그래머의 명시적 지시 없이 자동으로 발생함. 예를 들어, 일부 프로그래밍 언어에서 정수와 부동 소수점 숫자를 더하려고 할 때, 언어는 덧셈을 수행하기 전에 정수를 부동 소수점 숫자로 자동으로 변환할 수 있습니다.
    - 명시적 코어션: 프로그래머가 한 유형을 다른 유형으로 명시적으로 변환하는 방식. 예를 들어, 부동 소수점 숫자를 정수로 사용하고 싶다면, 명시적으로 정수로 캐스팅할 수 있습니다.
    - 출처: ChatGPT
