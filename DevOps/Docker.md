### 자주 사용되는 명령어
- `docker run`: 새로운 컨테이너를 생성하고 실행. 이 명령어는 이미지가 로컬 시스템에 없으면 Docker Hub에서 자동으로 이미지를 다운로드.
   - 예시: `docker run -d -p 80:80 nginx`은 nginx 웹 서버를 백그라운드에서 실행하고 호스트의 80 포트를 컨테이너의 80 포트에 바인딩함.
- `docker ps`: 실행 중인 컨테이너의 리스트를 보여줌. `-a` 옵션을 추가하면 중지된 컨테이너까지 모두 보여줌.
   - 예시: `docker ps -a`
- `docker stop`: 하나 이상의 실행 중인 컨테이너를 정지
   - 예시: `docker stop <컨테이너 ID 또는 이름>`
- `docker rm`: 하나 이상의 컨테이너를 삭제. 컨테이너가 실행 중이면 먼저 정지해야 함.
   - 예시: `docker rm <컨테이너 ID 또는 이름>`
- `docker images`: 로컬에 저장된 이미지의 리스트를 보여줌
   - 예시: `docker images`
- `docker rmi`: 하나 이상의 이미지를 삭제. 이미지를 사용하는 컨테이너가 없어야 함
   - 예시: `docker rmi <이미지 ID 또는 이름>`
- `docker build`: Dockerfile로부터 이미지를 생성. 이 명령어는 코드와 종속성을 포함한 완전한 실행 환경을 이미지로 만듦.
   - 예시: `docker build -t <이미지 이름>:<태그> .`
- `docker pull`: Docker Hub나 다른 레지스트리에서 이미지를 다운로드.
   - 예시: `docker pull nginx`
- `docker push`: 이미지를 Docker Hub나 다른 레지스트리에 업로드.
   - 예시: `docker push <사용자 이름>/<이미지 이름>:<태그>`
- `docker exec`: 실행 중인 컨테이너 내에서 명령어를 실행. 이를 통해 실행 중인 컨테이너에 접근하여 탐색하거나 문제를 진단할 수 있음.
    - 예시: `docker exec -it <컨테이너 ID 또는 이름> /bin/bash`

### $
- `$` 기호는 쉘(Shell) 스크립트와 커맨드 라인에서 변수 값을 참조하거나, 커맨드 치환(command substitution)을 수행할 때 사용됨
- `$(command)` 구문은 "command substitution"의 한 예로, 해당 커맨드를 실행하고, 그 결과값으로 치환되어 다른 커맨드의 입력으로 사용됨
- 예시
    - 명령어 `docker stop $(docker ps -q)`에서 `$(docker ps -q)` 부분은 `docker ps -q` 커맨드를 실행하여 현재 실행 중인 모든 컨테이너의 ID를 나열하고, 이 출력된 컨테이너 ID들이 `docker stop` 명령어의 인자로 전달되어, 모든 실행 중인 컨테이너를 정지시키는데 사용됨.
    - 즉, `$(docker ps -q)`는 `docker ps -q` 커맨드를 실행하고, 그 결과(실행 중인 컨테이너의 ID들)를 `docker stop` 명령어에 전달하는 역할을 함. 이는 쉘에게 `docker ps -q` 커맨드를 먼저 실행하라고 지시하고, 그 출력값을 `docker stop`의 입력으로 사용하도록 하는 방법.

### 내가 자주 사용했던 명령어
- docker stop $(docker ps -q)
    - docker ps -q: 현재 '실행 중인' 모든 컨테이너의 ID를 나열합니다. -q 플래그는 "quiet" 모드로, 컨테이너 ID만 출력
    - docker ps에 -a 플래그를 붙이면 '모든 컨테이너'의 ID를 나열. 그러나 docker stop 명령어는 이미 정지된 컨테이너에 아무런 효과가 없으므로 붙일 필요가 없음.
    - docker stop: 컨테이너를 정지. 여기서는 $(docker ps -q)를 통해 얻은 모든 실행 중인 컨테이너 ID를 사용하여 모든 실행 중인 컨테이너를 정지.
- docker rm $(docker ps -a -q)
    - docker rm: 하나 이상의 컨테이너를 삭제합니다.
    - 이 명령어는 docker ps -a -q를 통해 얻은 모든 컨테이너 ID를 사용하여 모든 컨테이너(실행 중이지 않은 것 포함)를 삭제합니다.
- docker rmi -f $(docker images -aq)
    - docker images -aq: 모든 도커 이미지의 ID를 나열. -a는 모든 이미지를 나열하고, -q는 이미지 ID만 출력합니다.
    - docker rmi -f: 하나 이상의 도커 이미지를 강제로 삭제. -f 플래그는 "force"를 의미. 여기서는 $(docker images -aq)를 통해 얻은 모든 이미지 ID를 사용하여 모든 도커 이미지를 강제로 삭제
- docker pull ${{ secrets.DOCKERHUB_USERNAME }}/app:latest
    - docker pull: 지정된 도커 이미지를 Docker Hub 같은 레지스트리에서 로컬 시스템으로 다운로드함
    - 여기서는 GitHub Actions의 시크릿(${{ secrets.DOCKERHUB_USERNAME }})을 사용하여 특정 사용자의 app 이미지 최신 버전을 다운로드함.
- echo "docker run"
    - echo: 터미널에 문자열을 출력합니다. 여기서는 "docker run"이라는 문자열을 출력하여 다음 도커 명령어 실행을 알림.
- docker run --rm -e DB_DB=... -p 8080:8000 -d --name container_name ${{ secrets.DOCKERHUB_USERNAME }}/app:latest
    - docker run: 새로운 컨테이너를 생성하고 실행합니다.
    - --rm: 컨테이너가 종료될 때 자동으로 삭제되도록 합니다.
    - -e: 환경변수를 설정합니다. 여기서는 데이터베이스 관련 여러 환경변수(DB_DB, DB_HOST, DB_PASSWORD, DB_PORT, DB_USER)를 설정합니다.
    - -p 8080:8000: 호스트의 8080 포트와 컨테이너의 8000 포트를 연결합니다.
    - -d: 컨테이너를 백그라운드에서 실행합니다.
    - --name: 컨테이너의 이름을 설정합니다. 여기서는 container_name으로 설정합니다.

### 명령어 잘 사용하기
- docker stop, docker rm, docker rmi 명령어가 실행되었을 때, 적어도 하나 이상의 컨테이너 또는 이미지가 실행 중이거나 존재해야 함. 그렇지 않으면 실행할 대상이 없다는 에러가 발생함. 아래와 같이 실행 중이거나 존재하는 대상이 없는 경우를 대비하여 조건을 체크하는 로직을 추가할 수 있음
    -  예시
        ```bash
        CONTAINERS=$(docker ps -q)
        if [ -n "$CONTAINERS" ]; then
        docker stop $CONTAINERS
        fi
        STOPPED_CONTAINERS=$(docker ps -a -q)
        if [ -n "$STOPPED_CONTAINERS" ]; then
        docker rm $STOPPED_CONTAINERS
        fi
        IMAGES=$(docker images -aq)
        if [ -n "$IMAGES" ]; then
        docker rmi -f $IMAGES
        fi
        ```
        - 여기서 -n은 쉘 스크립트에서 문자열을 테스트할 때 사용하는 조건 플래그. -z도 사용 가능.
        - -n: 주어진 문자열에 값이 있을 때 참을 반환. 즉, 문자열이 비어있지 않으면 참(true)
        - -z: 주어진 문자열이 "null" 이거나 길이가 0인지를 검사. 만약 문자열이 비어있으면 참(true)을 반환
- Docker CLI를 사용하여 로그인할 때 --password 옵션으로 비밀번호를 직접 입력하는 것이 보안상 안전하지 않음. 대신 --password-stdin 옵션을 사용하여 표준 입력을 통해 비밀번호를 안전하게 전달하도록 권장됨.
    - 예시
        ```bash
        echo $CR_PASSWORD | docker login -u $CR_USERNAME --password-stdin $CR_REGISTRY
        ```    

### 포트 바인딩, 포트 매핑
- 네트워크 통신에서 컨테이너와 외부 세게 간의 연결을 설정하는 데 사용되는 개념
- 특히 Docker와 같은 컨테이너 기술에서 이 두 용어는 컨테이너가 호스트의 네트워크 인터페이스와 어떻게 통신하는지를 정의하는 데 중요함
- 포트 바인딩과 포트 매핑의 차이점은 세부적인 용어 사용에 있지만, 비슷한 맥락에서 사용됨
- 포트 매핑(Port Mapping)
    - 정의: 포트 매핑은 호스트와 컨테이너 간의 네트워크 포트 연결을 정의하는 과정. 특히, 컨테이너 내부에서 사용하는 포트를 호스트의 특정 포트에 연결하는 것을 의미. 이를 통해 외부에서 컨테이너 내부의 애플리케이션에 접근할 수 있음.
    - 용례: 예를 들어, 컨테이너가 내부적으로 80번 포트를 사용하여 웹 서버를 실행하고 있을 때, 호스트의 8080번 포트를 컨테이너의 80번 포트에 매핑할 수 있음. 이렇게 설정하면, 외부에서 호스트의 8080번 포트로 요청을 보내면 그 요청이 컨테이너의 80번 포트로 전달됩니다.
- 포트 바인딩 (Port Binding)
    - 정의: 포트 바인딩은 특정 IP 주소와 포트에 애플리케이션을 연결하는 과정. 컨테이너 환경에서는 주로 포트 매핑의 일환으로 사용되는 용어. 호스트의 포트를 컨테이너의 포트에 바인딩함으로써, 컨테이너가 호스트의 네트워크 인터페이스를 통해 외부와 통신할 수 있도록 함.
    - 용례: 도커에서 docker run -p 8080:80 명령어를 사용하는 경우, 이는 호스트의 8080번 포트를 컨테이너의 80번 포트에 바인딩함. 여기서 -p 옵션은 포트 매핑(바인딩)을 설정하는 데 사용됨

### 포트 바인딩할 때 어떤 포트 번호를 사용할 것인가
- 호스트와 컨테이너 포트의 일치
    - 개발 환경: 개발 환경에서는 동일한 포트 번호를 사용하는 것이 편리할 수 있음. 예를 들어, 컨테이너 내부에서 사용하는 웹 애플리케이션이 80번 포트를 사용한다면, 호스트에서도 80번 포트로 바인딩하여 개발 과정을 간소화할 수 있음. 이렇게 하면, 포트 번호를 기억하고 관리하는 데 드는 노력을 줄일 수 있음.
- 운영 환경: 운영 환경에서는 보안, 충돌 회피, 다양한 서비스 관리 등의 이유로 다른 포트 번호를 사용하는 것이 일반적. 예를 들어, 여러 웹 애플리케이션이 동시에 호스트에서 실행될 경우, 각각의 애플리케이션에 대해 고유한 외부 포트를 할당하여 서비스 간 충돌을 방지할 수 있음.
- 포트 충돌 방지
    - 포트 충돌: 호스트에서 이미 사용 중인 포트에 다른 서비스를 바인딩하려고 하면 포트 충돌이 발생할 수 있음. 이러한 충돌을 방지하기 위해, 이미 사용 중인 포트와 다른 포트 번호를 선택하는 것이 중요.
- 보안 고려 사항
    - 비표준 포트 사용: 특정 서비스를 표준 포트가 아닌 다른 포트에 바인딩함으로써, 무작위 포트 스캔에 대한 노출을 줄일 수 있음. 예를 들어, 웹 서버를 80이나 443이 아닌 다른 포트에 배치하여 보안성을 높일 수 있음.

### 무작위 포트 스캔
- Port scanning
- 네트워크 상의 특정 대상에 대해 열려 있는 포트를 탐색하는 과정
- 해커나 보안 전문가가 네트워크 상의 서버, 라우터, 컴퓨터 등의 장비에 접속 가능한 포트를 찾기 위해 사용하는 기술
- 이 과정에서 공격자는 네트워크 상의 대상에 대해 다양한 포트 번호에 접근 시도를 하여, 어떤 포트가 열려 있는지, 즉 외부에서 접속 가능한 상태인지를 확인함
- 포트 스캔의 목적
    - 보안 취약점 발견: 네트워크에 연결된 장비들이 가지고 있는 보안 취약점을 찾아내기 위해 사용됨. 열려 있는 포트를 통해 해당 시스템이 어떤 서비스를 제공하고 있는지 파악할 수 있으며, 이를 통해 취약한 서비스를 타겟으로 공격을 시도할 수 있음.
    - 네트워크 매핑: 네트워크의 구성과 서비스를 파악하기 위해 사용됩니다. 네트워크 내에서 어떤 서비스가 동작 중인지, 어떤 시스템이 존재하는지 등을 파악할 수 있음.
- 포트 스캔의 유형
    - 무작위 포트 스캔: 임의의 포트 번호에 대해 스캔을 수행하여 열려 있는 포트를 찾아냄. 이 방식은 무작위성에 의존하므로, 모든 가능한 포트를 검사할 때까지 시간이 소요될 수 있음.
    - 특정 포트 스캔: 공격자가 특정 포트 또는 포트 범위에 초점을 맞추고 스캔을 진행하는 방식. 일반적으로 잘 알려진 서비스가 사용하는 포트나 취약점이 발견된 서비스의 포트가 대상이 됨.
- 대응 방안
    - 방화벽 설정: 불필요한 포트는 닫고, 필요한 포트만 열어 두어야 함. 방화벽을 통해 무작위 포트 스캔을 탐지하고 차단할 수 있음.
    - 서비스 최신화: 소프트웨어와 서비스를 최신 상태로 유지하여 알려진 취약점에 대한 패치를 적용해야 함.
    - 보안 정책 강화: 네트워크 접근 정책을 강화하고, 정기적인 보안 감사와 취약점 스캔을 수행하여 보안 수준을 유지해야 함.

### GPG 키
- GPG(GNU Privacy Guard) 키는 데이터의 암호화와 디지털 서명을 위해 사용되는 공개 키 암호화 시스템의 일부
- GPG는 PGP(Pretty Good Privacy)의 자유 소프트웨어 대안으로 개발되었으며, 개인 간의 데이터 통신을 암호화하고, 디지털 서명을 통해 메시지나 파일이 변경되지 않고 전송자가 주장하는 사람임을 검증하는 데 사용됨
- 구성 요소
    - 공개 키(Public Key): 다른 사람들과 공유될 수 있는 키. 이 키를 사용하여 당신에게 메시지를 암호화하거나, 당신의 서명을 검증할 수 있음.
    - 비밀 키(Private Key) 또는 개인 키(Secret Key): 절대로 다른 사람과 공유해서는 안 되는 키. 이 키로 자신의 메시지를 복호화하거나, 디지털 서명을 생성할 수 있음.
- GPG 키의 사용 목적
    - 암호화: 공개 키를 사용하여 데이터를 암호화하면, 해당 데이터는 해당 공개 키와 쌍을 이루는 비밀 키를 가진 사용자만이 복호화할 수 있음. 이는 이메일, 파일 등의 보안 전송을 보장함.
    - 디지털 서명: 문서나 메시지에 디지털 서명을 할 때, 발신자의 비밀 키를 사용하여 생성함. 수신자는 발신자의 공개 키를 사용하여 서명을 검증할 수 있음. 이는 데이터의 무결성과 발신자의 인증을 보장함.
- Docker 설치와 관련된 GPG 키: Docker를 설치할 때 사용하는 GPG 키는 Docker의 패키지 저장소가 실제로 Docker Inc.에 의해 관리되고 있으며 안전하다는 것을 보증함. 즉, 설치하려는 소프트웨어 패키지가 변조되지 않았음을 확인할 수 있는 역할을 함. 이 과정은 사용자가 신뢰할 수 있는 소스로부터 소프트웨어를 받고 있다는 추가적인 보증을 제공함.

